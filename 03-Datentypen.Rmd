# Grundlagen

*Der Beitrag wurde das letzte mal am `r format(Sys.time(), '%d %B, %Y')` editiert*

```{r include=FALSE}

knitr::opts_chunk$set(fig.align = "center", collapse = T, echo = TRUE, message = FALSE, warning = FALSE)

# With collapse = TRUE the Source and output lived together happily ever in knitr.
# https://github.com/yihui/knitr-examples/blob/master/039-merge.md

# loading multiple packages at once with `pacman`
# create a vector name
packages <- c("tidyverse", "markdown", "knitr", "matrixStats", "patchwork", "lubridate", "plotly",  "naniar", "stlplus", "gt", "dygraphs", "htmltools", "zoo", "xts", "ggpmisc", "forcats", "RColorBrewer", "Kendall", "rstudioapi", "multcompView", "plyr", "bookdown", "janitor")
 
# Load the packages vector 
pacman::p_load(packages, character.only = T)


my_theme <- theme(
  panel.background = element_rect(fill = "white", color = "black"),
  panel.grid.major = element_blank(), 
  panel.grid.minor = element_blank(), 
  panel.border = element_blank())

```

Im folgenden lernen wir mehr zu Datentypen in R und welche Rolle sie spielen. Ganz grundlegend lassen sich verschiedene Strukturen unterscheiden [Zusammenfassung](https://statsandr.com/blog/variable-types-and-examples/):

```{r echo=FALSE, fig.cap="Grundlegende Datenstruktur"}
knitr::include_graphics("images/013a.png")
```

* **Quantitative Variablen** sind nummerisch und können gemessen werden
    + **Diskret** zählbar mit einer finiten Anzahl an Möglichkeiten
        -   Anzahl Kinder einer Familie
        -   Studenten in einem Klassenzimmer
        -   Brötchen in einer Tüte
    + **Kontinuierlich** nicht-zählbar mit einer infiniten Anzahl an Möglichkeiten
        -   Alter (e.g. ein 28-jähriger Mann kann spezifischer ausgedrückt 28 Jahre, 7 Monate, 16 Tage, 3 Stunden, 4 Minuten, 5 Sekunden, 31 Milisekunden, ... alt sein. Alle Messungen stoppen per Konvention bei einem gewissen Level an Präzision, was uns aber nicht stoppen muss höherauflösend zu messen. Dies bedingt das unser Messwert eine infinite Anzahl an Möglichkeiten aufweisen kann.
        - Gewicht
        - Größe

* **Qualitative Variable** oder kategorische Variable (factor in R) sind nicht-numerisch und die Werte passen in eine Kategorie
    + **Nominal** keine Hierarchie oder Ordnung in den Werten (e.g. Geschlecht (männlich/weiblich) hat keine interne Struktur
    + **Ordinal** hat eine interne Ordnung (e.g. Gesundheitsstatus differenziert nach schlecht/mäßig/gut/hervorragend)
    
```{r echo=F, fig.cap="Illustration von @allison_horst: https://twitter.com/allison_horst"}
knitr::include_graphics("images/018.png")
```

```{r echo=F, fig.cap="Illustration von @allison_horst: https://twitter.com/allison_horst"}
knitr::include_graphics("images/019.png")
```

## Datentypen

Im folgenden werden die vier grundlegenden **Datentypen** (*atomic vectors*) behandelt:

* `logical` (TRUE, FALSE)
* `integer` (c(1, 2.4, 4.678))
* `double` (auch als `numeric` bezeichnet; c(1L, 2L, 3L))
* `character` (c("these are", "some strings"))

```{r echo=FALSE, fig.cap="Atomic vectors, source: https://adv-r.hadley.nz/vectors-chap.html"}
knitr::include_graphics("images/079.png")
```


Diese Datentypen können in Form bestimmter Datenstrukturen miteinander verknüft werden. In R ist dies über die Dimensionalität der Daten definiert mit den fünf häufigsten Strukturen:

|  |Homogen|Heterogen|
|:--|:--|:--|
|1d|Atomic vector|List|
|2d|Matrix|Data frame|
|nd|Array||

Table: Datenstrukturen in R

🔍 [Advanced R by Hadly Wickham](https://adv-r.hadley.nz/)

### Numerische Objekte

Zahlenwerte in R werden als `numeric` bezeichnet mit der Unterteilung in `integer` (ganze Zahlen) oder `double` (Dezimalzahlen). Die Zuweisung von R, selbst wenn ich eine ganze Zahl zuweise, ist jedoch vom Typ double. 

```{r}
a <- 4
typeof(a)
```

💡 Mit der Funktion `typeof()` kann der Objekttyp erfragt werden.

Um eine ganze Zahl wiederzugeben muss ein L hinter die Zahl gesetzt werden. 

```{r}
a <- 4L
typeof(a)
```

### Textobjekte 

Ein `character` Objekt sind Namen wie `"Kristof"`, `"Tim"`, `"Beste Norddeutschland Exkursion der Welt"` (Textvariablen werden auch als *string* bezeichnet). Um ein `character` Objekt zu definieren sind die Anführungsstriche als einfache `' '` oder doppelte `" "` Anführungszeichen wichtig!

```{r}
# Dies sind alles character Objekte 
"Kristof"
"Tim"
"Beste Norddeutschland Exkursion der Welt"
```

Bestimmte Funktionen brauchen einen numerical input, wohingegen andere einen character input benötigen. Schaue was passiert:

```{r eval = F}
mean(c("5", "1"))
```

**Warnmeldung:In mean.default(c("5", "1")) :Argument ist weder numerisch noch boolesch: gebe NA zurück**

Lasse ich die Anführungsstriche weg, dann ist wieder alles im Lot:

```{r}
mean(c(5, 1))
```

### Logicals 

Der dritte wichtige Objekttyp in R lautet `logical` und dieser kann zwei Werte annehmen: `TRUE` (wahr) und `FALSE` (falsch). Logicals entstehen durch den logischen Vergleich zwischen zwei Werten oder den Elementen eines Vektors. Operatoren die für diese Anfrage genutzt werden können lauten:

|Operator | Bedeutung | Beispiel |
|:---|:---|:---|
| == | ist gleich                       | 1==1 (ergibt `TRUE`) "a"=="b" (ergibt `FALSE`) |
| != | ist nicht gleich                 | 1 != 1 (ergibt `FALSE`) "a" != "b" (ergibt `TRUE`) |
| <  | ist kleiner als                  | 1 < 2 (ergibt `TRUE`) 2 < 2 (ergibt `FALSE`) |
| >  | ist größer als                   | 2 > 1 (ergibt `TRUE`) 2 > 2 (ergibt `FALSE`) |
| <= | ist kleiner gleich               | 1 <= 2 (ergibt `TRUE`) 2 <= 2 (ergibt `TRUE`) |
| >= | ist größer gleich                | 2 >= 1 (ergibt `TRUE`) 2 >= 2 (ergibt `TRUE`) |

Table: Logische Operatoren in R.

### Fehlende Werte

In R werden fehlende Werte mit `NA` für `not available` gekennzeichnet. Für bestimmte Funktionen und Anwendungen ist es wichtig, falls ein `NA` Wert in einer Zeitreihe auftritt (🤯 ...leider ist dies in langen Zeitreihen fast immer der Fall), R explizit zu sagen was mit diesen Werten getan werden soll. 

```{r}
# Ich habe einen Vektor mit einem fehlenden Wert NA
a <- c(1,2,3,4,NA,5)
mean(a)
```
Hm...der Mittelwert von 1,2,3,4,NA und 5 ist NA und nicht eine Zahl? Wie kommt das bloß. In dem Fall ist es nützlich in die Dokumentation der Funktion `mean()` nachzuschauen. 

```{r eval = F}
?mean
```

**Default S3 method: mean(x, trim = 0, na.rm = FALSE, ...)**

Die default Argumente der Funktion lauten `na.rm = FALSE`, was soviel bedeutet **na** Werte nicht zu entfernen sondern in die Berechnung mit einzubeziehen. 

💡 na steht für fehlende Werte (NA) und rm ist die Kurzform für remove, also entfernen. 

Damit unsere Rechnung funktioniert müssen wir in der `mean()` Funktion das Argument `na.rm = TRUE` setzen, also erst die fehlende Werte entfernen und dann den Mittelwert berechnen:

```{r}
mean(a, na.rm = TRUE)
```
💪 Es funktioniert! Dies ist tatsächlich einer der häufigsten Fehler und egal wie häufig man daran denkt, es kommt immer wieder vor das dies einer der Gründe ist warum man sich Stunden den Kopf über ein nicht funktionierendes Skript zerbricht 🤯

### Weitere Objekttypen

Neben den drei vermeintlich wichtigsten Objekttypen (`numeric`, `character`, `logical`) gibt es in R noch die Typen für 

* Kategoriale Variablen `factor`
* Datumsangaben `date`
* Datumsangaben + Zeit `datetime` 
* ... und weitere

Wenn man Daten in R einliest muss man R jedoch einen Schubser geben, damit eine Spalte bspw. auch als `date`erkannt wird und nicht als `character` oder `numeric`. Wie man dies berücksichtigt lernen wir in dem Kapitel **Daten einlesen**. 

#### S3 Objekte

Vektoren in R weisen verschiedene Attribute auf. Die zwei wichtigsten Attribute sind:

* dimension (wandelt einen Vektor in eine Matrix oder Liste um)
* class (bedient S3 Objekte, bspw. `factor`, `date` und `POSIXct`)

Wenn ein Objekt in R ein *class* Attribut besitzt wird es automatisch in ein **S3 object** umgewandelt und unterscheidet sich dadurch von einem normalen Vektor. 

```{r echo=F, fig.cap="S3 atomic vectors, source: https://adv-r.hadley.nz/vectors-chap.html#s3-atomic-vectors"}
knitr::include_graphics("images/080.png")
```

`factor` sind bspw. aufgebaut aus den Attributen `class` und `levels` um kategorische Daten zu speichern. 

### Objekttypen ändern

Die Syntax in R um Objekte umzuwandeln lautet `as.[Objekttyp]`.

```{r}
a <- "25"
typeof(a)
a <- as.numeric(a)
typeof(a)
```

Dies klappt allerdings nur, insofern die Umwandlung logisch ist. In allen anderen Fällen gibt es eine Warnmeldung unter Erzeugung von `NA`s anstelle der Werte. 

```{r eval = F}
a <- as.numeric("Beste Norddeutschland Exkursion der Welt")
```

**## Warning: NAs introduced by coercion**

## Datenstrukturen

```{r echo=F, fig.cap="Vergleich eines Skalars und eines Vektors", out.width="50%"}
knitr::include_graphics("images/015.png")
```

Der einfachste Datentyp in R ist ein Skalar ([Mathematische Größe, die allein durch die Angabe eines *Zahlen*wertes charakterisiert ist](https://de.wikipedia.org/wiki/Skalar_(Mathematik))). Im Gegensatz zu der mathematischen Beschreibung, kann in R ein Skalar jedoch `character` sein und muss nicht zwangsläufig als `numeric` definiert sein. Mathematische Operationen sind mit `numerischen` Skalaren möglich, nicht jedoch wenn diese in R als `character` gespeichert sind. 

```{r eval = F}
a <- "1"
b <- "2"
a + b
```

**Fehler in a + b : nicht-numerisches Argument für binären Operator**

Bisher haben wir einfache Objekte in R erzeugt, wie eben genau Skalare oder kürzere Vektoren. Es gibt jedoch noch weitere Datenstrukturen, die sich hinsichtlich der Dimensionalität unterscheiden (1D und 2D) und ob die Objekttypen homogen (nur ein Objekttyp) und heterogen (unterschiedliche Objekttypen) beinhalten:

|Datenstruktur |	Dimensionalität |	Objekttypen|
|Vektor |	eindimensional |	homogen|
|Liste |	eindimensional 	|heterogen|
|Matrix |	zweidimensional |	homogen|
|Dataframe |	zweidimensional 	|heterogen|

Table: Datenstrukturen in R. 

### Vektor 

Ein Vektor ist eine Ansammlung von Skalaren, die als ein R Objekt gespeichert wurden. Die Zahlen von 1 bis 10 bspw. bilden einen numerischen Vektor mit der Länge 10. Die Buchstaben im Alphabet sind ein Vektor mit der Länge 26. 

🚨 Vektoren können nur `numeric` **oder** `character` sein...nicht beides!

Es gibt verschiedene Möglichkeiten einen Vektor selber zu bilden. 


| Funktion| Beispiel|Ergebnis|
|:--|:--|:--|
|`c(a, b, ...)`|`c(1, 5, 9)`|`r c(1, 5, 9)`|
|`a:b`|`1:5`|`r 1:5`|
|`seq(from, to, by, length.out)`|`seq(from = 0, to = 6, by = 2)`|`r seq(from = 0, to = 6, by = 2)`|
|`rep(x, times, each, length.out)`|`rep(c(7, 8), times = 2, each = 2)`|`r rep(c(7, 8), times = 2, each = 2)`|

Table: Funktionen um einen Vektor zu erzeugen.

Die einfachste Möglichkeit einen Vektor zu erzeugen ist mit der `c()` Funktion. "c" leitet sich von dem englischen Wort concatenate ab und lässt sich frei übersetzen mit "zusammenbringen" oder "zusammenführen". 

```{r echo = T}
# Speichere einen Vektor mit den Zahlen von 1 bis 10 
a <- c(1,2,3,4,5,6,7,8,9,10)
# Stelle die Zahlen dar
a
```

Man kann auch Vektoren miteinander verknüpfen:

```{r echo = T}
a <- c(1,2,3,4,5)
b <- c(6,7,8,9,10)
x <- c(a, b)
x
```

😎 Yeah! Das hat ja gut geklappt. 

Man kann auch `character` Vektoren erstellen mit demselben Prinzip

```{r echo = T}
wort_vec <- c("Beste", "Exkursion", "der", "Welt")
wort_vec
```

Wenn ihr allerdings einen Vektor von 1:1000 erstellen wollt... 🤯
Aber keine Sorge! Auch hierfür gibt es Funktionen in R um das Leben zu erleichtern. 

#### a:b

Die Vektoren werden in Inkrementen von 1 aufgefüllt 

```{r echo = T}
1:10
# Das ganze geht auch Rückwärts
10:1
# Oder mit nicht runden Zahlen (non-integers)
2.5:8.5
```

#### seq()

Diese Funktion musste ich für Zeitreihenuntersuchungen schon öfter verwenden und ist ein wahrer Retter in der Not.

| Argument| Definition|
|:-------------------------|:-----------------------------|
|     `from`|    Beginn der Sequenz |
|     `to`|     Ende der Sequenz |
|     `by`|    Die Inkremente|
|     `length.out`|   Die gewünschte Länge der Sequent (nur wichtig wenn `by` festgelegt wurde)|

```{r echo = T}
# Erstelle Nummer von 1 bis 10 in einer Schritten
seq(from = 1, to = 10, by = 1)
# Erstelle ganze Zahlen von 0 bis 100 in 10er Schritten
seq(from = 0, to = 100, by = 10)
```

Wenn das Argument `length.out` verwendet wird, entspricht die Länge des Vektors dem Wert von `length.out`. 

```{r echo = T}
# Erstelle 10 Zahlen von 1 bis 5
seq(from = 1, to = 5, length.out = 10)
# Erstelle 3 Zahlen von 0 bis 100
seq(from = 0, to = 100, length.out = 3)
```

#### rep()

| Argument| Definition|
|:-------------------------|:-----------------------------|
|     `x`               | Ein Skalar oder Vektor der wiederholt werden soll |
|     `times`           | Die Anzahl wie häufig `x` wiederholt werden soll |
|     `each`            | Die Anzahl wie häufig jeder Wert in `x` wiederholt werden soll|
|     `length.out`      | Die gewünschte Länge der Sequenz|

Die rep() Funktion erlaubt es also einen Skalar oder Vektor beliebig oft zu wiederholen. 

```{r echo = T}
rep(x = 3, times = 10)
rep(x = c(1, 2), each = 3)
rep(x = 1:3, length.out = 10)
```

💡 Man kann eine `a:b` Funktion mit einer `rep()` Funktion verknüpfen.
💡 Sogar das `times` und `each` Argument lassen sich in die `rep()` Funktion integrieren

```{r echo = T}
rep(x = 1:3, each = 2, times = 2)
```

#### Vektorelemente auswählen

Um auf eine Zahl in einem Vektor zuzugreifen können wir dies über eine eckige Klammer `[]` tun. 

```{r}
a <- c(1,2,3,4,5)
a[2]
a[5]
```

Wenn wir mehrere Elemente des Vektors auswählen möchten, dann müssen wir einen neuen Vektor über die Positionen erzeugen, beispielsweise um das erste, dritte und fünfte Element des Vektors auszugeben:

```{r}
a[c(1,3,5)]
```

Eine weitere Möglichkeite die ersten drei Elemente eines Vektors auszuwählen ist mit dem Doppelpunkt `:` was so viel bedeutet wie *von bis*. 

```{r}
a[1:4]
```

Elemente in einem Vektor können auch mit `=` benannt werden. Bei der Benennung von Spaltennamen in einer Tabelle (dataframe oder Matrix in R) ist der Befehl ähnlich. 

```{r}
namen <- c(eins = "Dies", zwei = "ist", drei = "ein", vier = "Test")
namen
namen["vier"]
```

### Liste

Listen ähneln Vektoren und können über die Funktion `list()` erzeugt werden. Beispielsweise der Standort Speicherkoog kann als Liste wie folgt erzeugt werden:

```{r}
koog <- list(country = "Germany", state = "Schleswig-Holstein", city = "Meldorf", name = "Speicherkoog")
koog
```

Die Darstellung gegenüber Vektoren ist jedoch eine andere. Anstelle der Darstellung nebeneinander werden die Listen Elemente untereinander dargestellt. 

### Matrix und dataframe

```{r echo=F, fig.cap="Darstellung von Datenstrukturen", out.width="50%"}
knitr::include_graphics("images/020.png")
```


#### Matrix

Eine Matrix ist eine zweidimensionale Struktur und kann mit der Funktion `matrix()` erzeugt werden. 

```{r}
# Erstelle einen Vektor von 1 bis 10
a <- c(1:10)
# Teile den Vektor auf zwei Spalten auf
b <- matrix(a, ncol = 2)
b
# Teile den Vektor auf zwei Zeilen auf
c <- matrix(a, nrow = 2)
c
```

Mit der Funktion `rbind()` (row = Zeile) oder `cbind()` (column = Spalte) können wir mehrere Vektoren auch zusammenführen. 

```{r}
a <- c(1:10)
b <- c(11:20)
c <- c(21:30)
# Erstelle eine Matrix mit drei Spalten
cbind(a,b,c)
# Erstelle eine Matrix mit drei Zeilen
rbind(a,b,c)
```

Die Spalten- oder Zeilennamen einer Matrix können auch benannt oder umbenannt werden mit der Funktion `colnames()` oder `rownames()`.

```{r}
mat <- rbind(a,b,c)
mat
rownames(mat) <- c("Zeile 1", "Zeile 2", "Zeile 3")
mat
```

Eine nützliche Funktion lautet `t()` um eine Matrix oder dataframe zu **transponieren**, also umzuwandeln und um 90° zu vertauschen.

```{r}
# Transponiere die Matrix mat 
t(mat)
```

Unsere Zeilennamen machen jetzt natürlich keinen Sinn mehr 🙃 Versuche mal die Spaltennamen richtig zu beschriften. 

#### Dataframe

Eine Matrix ähnelt der Datenstruktur wie man sie aus Excel, SPSS etc. kennt. Großer Unterschied ist aber, dass eine Matrix nur **einen** Datentyp erlaubt und ein dataframe **mehrere** Typen. Mit der Funktion `data.frame()` können wir gleich lange Vektoren unterschiedlichen Typs kombinieren.

```{r}
# Erstelle einen dataframe
beatles_data <- data.frame(
  name = c("John", "Paul", "George", "Ringo"),
  surname = c("Lennon", "McCartney", "Harrison", "Starr"),
  born = c(1940, 1942, 1943, 1940)
)
beatles_data
```

Die händische Eingabe von tabellarischen Daten wäre natürlich umständlich. In R gibt es einfache Möglichkeiten diese aus externen Datenquellen (z.B. CSV, Excel, txt, ...) einzulesen und zu verarbeiten. 

#### tibble

`tibble` haben dieselbe Datenstruktur wie `data.frame`, nur das Attribut `class` in einem tibble ist länger:

```{r}
# create a data frame
df1 <- data.frame(
  x = c("a", "b", "c"),
  y = c(1,2,3)
)
typeof(df1)
attributes(df1)

# create a tibble
df2 <- tibble(
  x = c("a", "b", "c"),
  y = c(1,2,3)
)
typeof(df2)
attributes(df2)

```




## Zufallszahlen erzeugen

R ist eine Statistiksprache und da wäre es doch verwunderlich wenn es nicht auch Funktionen gibt, um Zufallszahlen zu erzeugen. Für Vektoren ist dies die Funktion `sample()`:

| Argument| Definition|
|:---------|:---------------------------------------------|
|     `x`|    Ein Vektor (character oder numeric) von dem die Zufallszahlen erzeugt werden.|
|     `size`|     Die Anzahl der Zufallszahlen. Der Standard (default) ist die Länge des Vektors `x`.|
|     `replace`|    Standard ist `FALSE`. Bei `TRUE` kann die Zahl mehrmals vorkommen.|
|     `prob`|   Ein Vektor der Möglichkeiten für `x` mit der Wahrs `x` is. The vector of probabilities you give as an argument should add up to one. If you don't specify the `prob` argument, all outcomes will be equally likely.|

```{r echo = T}
# Die Zahlen 1 bis 5 treten nur einmal auf
sample(x = 1:5, size = 5)
# Die Zahlen 1 bis 5 können ggf. mehrmals auftreten hei replace = TRUE
sample(x = 1:5, size = 5, replace = T)
```

```{r echo=F, fig.cap="Illustration von @allison_horst: https://twitter.com/allison_horst"}
knitr::include_graphics("images/017.png")
```


Die erzeugten Zufallsvariablen können dabei **normalverteilt** oder **nicht-normalverteilt** sein. Es gibt jedoch noch eine Vielzahl weiterer Funktionen in R, die mit dem help Befehl aufgerufen werden können

```{r eval = F, echo = T}
?Distributions
```

Die normale Standardverteilung (auch bekannt unter Gausssche Normalverteilung) kann mit der Funktion `rnorm` erzeugt werden. Es können dabei die folgenden Argumente gesetzt werden. 

| Argument| Definition|
|:---------|:---------------------------------------------|
|     `n`|     Stichprobenanzahl.|
|     `mean`|      Mittelwert der Verteilung.|
|     `sd`|     Standardabweichung der Verteilung.|

```{r echo = T}
# Erstelle 100000 Zahlen mit dem Mittelwert 10 und der Standardverteilung 3
a <- rnorm(n = 100000, mean = 10, sd = 3)
a <- as.data.frame(a)
# Erstelle zwei weitere Spalten. Selber Mittelwert aber unterschiedliche SD 
# Keine Sorge! Was das komische Symbol %>% bedeutet lernen wir später
colnames(a) <- c("norm_3")
a <- a %>%
    mutate(norm_1 = rnorm(n = 100000, mean = 10, sd = 1)) %>%
    mutate(norm_0.5 = rnorm(n = 100000, mean = 10, sd = 0.5)) %>%
    pivot_longer(cols = everything())
# Erstelle die Abbildung mit ggplot...keine Sorge. Die Power von ggplot lernt ihr später kennen. 
a %>%
    ggplot(aes(x = value, color = fct_reorder(.f = name, .x = value, .fun = max))) +
    geom_density(alpha = 0.1) +
    scale_color_discrete(name = "Standardabweichung") +
    my_theme
```

Das Erzeugen der Daten ist spielend leicht. Plotten der Daten vermittelt weiterhin einen Eindruck davon, wie die Dichteverteilung der Daten variiert bei gleichem `mean()` aber unterschiedlicher `sd()`. 
Was sagt euch die Stichprobenanzahl über das Aussehen der Kurve aus?

```{r echo = T}
# Normalverteilung bei 10 Zufallszahlen
a <- rnorm(n = 10, mean = 10, sd = 3) %>% as.data.frame()
p1 <- a %>%
    ggplot(aes(x = .)) +
    geom_density(alpha = 0.1) +
    labs(
        title = "n = 10"
    ) +
    geom_vline(aes(xintercept = mean(.)), color = "red") +
    my_theme
# Normalverteilung bei 100 Zufallszahlen
a <- rnorm(n = 100, mean = 10, sd = 3) %>% as.data.frame()
p2 <- a %>%
    ggplot(aes(x = .)) +
    geom_density(alpha = 0.1) +
    labs(
        title = "n = 100"
    ) +
    geom_vline(aes(xintercept = mean(.)), color = "red") +
    my_theme
# Normalverteilung bei 100.000 Zufallszahlen
a <- rnorm(n = 100000, mean = 10, sd = 3) %>% as.data.frame()
p3 <- a %>%
    ggplot(aes(x = .)) +
    geom_density(alpha = 0.1) +
    labs(
        title = "n = 100.000"
    ) +
    geom_vline(aes(xintercept = mean(.)), color = "red") +
    my_theme

p1 + p2 + p3
```

🚨 Jedes mal wenn das Skript neu ausgeführt wird, ändern sich auch die Zufallszahlen. 

## Rechnen mit Vektoren

Es lassen sich mit Vektoren mathematische Operationen und zusammenfassende Statistiken durchführen. Im folgenden wollen wir Redoxpotenziale umrechnen, welche mit einer Silber-Silberchlorid Elektrode gemessen wurden. Für die Vergleichbarkeit und korrekte Nomenklatur sollten die Werte jedoch immer gegen die Standardwasserstoffelektrode (SHE) angegeben werden. Das Potenzial der SHE ist bei 25 °C um +207 mV größer, als das der Ag-AgCl Elektrode. Was müssen wir also tun? Wir müssen auf jeden Wert +207 mV addieren. Kein Problem in R:

```{r echo = T}
# Ein Vektor mit gemessenen Redoxpotenzialen einer Ag-AgCl Elektrode
# Die Funktion `runif()` erzeugt Werte mit einer stetigen Gleichverteilung zwischen min() und max()
e_agcl <- runif(n = 100, min = 400, max = 500)
# Addition von +207 mV auf jeden Wert des Vektors 
eh <- e_agcl + 207
# Erstelle einen data frame aus den beiden Vektoren 
df <- data.frame(e_agcl, eh) 
df <- df %>%
    mutate(n = seq(from = 1, to = nrow(df))) %>% 
    pivot_longer(cols = c("e_agcl", "eh"))
# Plotte die Darstellung
df %>%
    ggplot(aes(n, value, color = name)) +
    geom_line() +
    labs(
        title = "Verlauf der Redoxpotenziale (korrigiert und unkorrigiert)", 
        x = "Zeit", 
        y = expression(paste("E"[H], " (mV)"))
    ) +
    coord_cartesian(ylim = c(0, 800)) +
    my_theme
```

Wenn wir mathematische Berechnungen mit einem Skalar an einem Vektor durchführen (in unserem Fall +207 mV), dann führt R die Berechnung für jedes Element des Vektors durch. Es ist nicht nur Addition möglich, sondern auch Subtraktion, Multiplikation und Division. Selbst logarithmieren und entlogarithmieren etc. ist kein Problem. 

Eine Zusammfassung der möglichen Operationen seht ihr unten:

| Funktion| Beispiel|Ergebnis |
|:-------------------|:----------------------|:-----------------------|
|     `sum(x), product(x)`|    `sum(1:10)` |`r sum(1:10)`     |
|     `min(x), max(x)`|    `min(1:10)`|`r min(1:10)`    |
|     `mean(x), median(x)`|    `mean(1:10)`     | `r mean(1:10)` |
|     `sd(x), var(x), range(x)`|    `sd(1:10)` | `r sd(1:10)` |
|     `quantile(x, probs)`|    `quantile(1:10, probs = .2)`|`r quantile(1:10, probs = .2)`     |
|     `summary(x)`|    `summary(1:10)`|`Min = 1.00. 1st Qu. = 3.25, Median = 5.50, Mean = 5.50, 3rd Qu. = 7.75, Max = 10.0`     |

Table: Statistik Funktionen in R.

Lasst uns den Mittelwert und die Standardabweichung des Redoxpotentziales der Zeitreihe berechnen (wenn nicht explizit erwähnt beziehe ich mich immer auf den E~H~ Wert in mV gemessen). 

```{r echo = T}
# Mittelwert 
mean(eh)
# SD
sd(eh)
```

Kein Problem mehr für uns 😎

Vektoren sind simple 1-dimensionale Objekte in R. Wir haben jedoch auch schon Objekte wie Matrix, dataframe oder Listen kennengelernt. Eine grundlegende Sache einer Matrix oder eines dataframe ist es, dass die Vektoren **diesselbe** Länge haben müssen! Dies lässt sich mit der Funktion `length()` überprüfen. Wie lang war nochmal unser `eh` Vektor?

```{r}
length(eh)
```

Die `length()` Funktion ist nicht die einzige wichtige Funktion um mit Vektoren oder Daten im Allgemeinen zu arbeiten. Für eure Arbeit mit R sind folgende wichtig:

| Funktion| Beschreibung | Beispiel|Ergebnis |
|:------------|:------------------|:-------------------------|:----------|
|     `round(x, digits)`|  Runde Elemente in x zu `digits` Stellen |   `round(c(2.231, 3.1415), digits = 1)` |`r round(c(2.231, 3.1415), digits = 1)`     |
|     `ceiling(x), floor(x)`|  Runde Elemente in x Auf (oder ab) zur nächsten ganzen Zahl |  `ceiling(c(5.1, 7.9))`| `r ceiling(c(5.1, 7.9))`|
|     `x %% y`|  Ganzzahlige Division (ie. x durch y) |  `7 %% 3`|`r 7 %% 3` |

## str() Funktion

Eine wichtige Funktion um Informationen über einen Datensatz oder ein Objekt zu bekommen ist die Funktion `str()`, kurz für **structure**. Diese Funktion lässt sich auf alle Datenstrukturen in R anweden, also für Vektoren, Listen, Matrix und dataframes. 

```{r}
# Erkunden eines Vektors mit 100 Zufallszahlen
str(eh)
```

Hier kann man folgende Informationen draus ablesen:

* Es handelt sich um ein `numeric` Datenformat
* Der Vektor hat 100 Elemente von 1 bis 100
* Die ersten fünf Zahlen lauten ...

Haben wir ein komplizierteres Objekt wie den mtcars Datensatz wird die `str()` Auflistung etwas komplexer:

```{r}
# Erkunden des Datensatzes mtcars
str(mtcars)
```

Wir können an der Datenstruktur erkennen, dass es sich um einen `data.frame` handelt mit 32 observations von 11 Variablen. Alle haben den Datentyp `numeric`. Die Liste ist jedoch so lang, dass sie nicht komplett dargestellt wird. Wollen wir nur die ersten fünf Einträge anzeigen geht dies mit der `head()` Funktion und die letzten fünf Einträge mit der `tail()` Funktion:

```{r}
head(mtcars, n = 5)
tail(mtcars, n = 5)
```

Wenn man den Namen des Datensatzes / Objektes in die Funktion `View()` - V dabei groß geschrieben - eingibt, dann kann man sich den Datensatz auch im Viewer Fenster von R ansehen. 

```{r eval = F}
View(mtcars)
```

## Selektion von Spalten/Zeilen in dataframes 

Man kann auf einen einzelnen Vektor des `mtcars` dataframes zugreifen, indem man den Namen des Datensatzes mit dem `$` und weiterhin mit dem Spaltennamen verknüpft:

```{r}
# Zeige mit die Pferdestärken (hp) der Fahrzeuge an
mtcars$hp
```

Das Ergebnis ist ein Vektor, mit dem wir die bekannten Vektorfunktionen anwenden können. Die eckige Zahl zu Beginn der Zeile steht dabei für das `i`te Element des Vektors. Die Zahl 110 steht also auf der Position (dem Index) [1] und die Zahl 245 and Position [24]. Die Darstellung erleichert es einen Überblick über die Anzahl an Elementen zu bekommen.  

```{r}
mean(mtcars$hp)
```

Die Autos haben im Mittel also 146 PS, bereits 1974 😎

Auch mit `[]` kann auf Vektoren in einem dataframe zugegriffen werden. Der Spaltenname muss hierbei jedoch in `""` gesetzt werden. 

```{r}
head(mtcars["hp"], 5)
```

Wenn wir die Position der Spalte `hp` kennen genügt aber auch die Zahl 

```{r}
head(mtcars[4], 5)
```

Last but not least, eine letzte Möglichkeit Daten zu spezifizieren ist durch das Setzen eines Kommas:

```{r}
# Wähle die ersten zwei Zeilen aus aber ALLE Spalten
head(mtcars[1:2, ], 5)
# Wähle die ersten zwei Spalten aus aber ALLE Zeilen
head(mtcars[ ,1:2], 5)
```

Der Abschnitt vor dem `,` bezieht sich also auf die *Zeilen* und danach auf die *Spalten*. 

Mit `subset()` kann man noch spezifischer auf den Inhalt eines dataframes zugreifen und auch mit logischen Operatoren arbeiten. Es ist eine der wichtigsten Funktionen um auf Daten zurückzugreifen. 

| Argument| Beschreibung| 
|:------------------------|:-----------------------------|
|     `x`| Name des dataframes| 
|     `subset`| Ein logischer Vektor der Werte die man behalten möchte | 
|     `select`| Die Spalten die man behalten möchte | 

```{r}
# Wähle nur Autos mit mehr als 5 Zylinder aus
head(subset(mtcars,
       subset = cyl > 5), 5)
# Wähle nur Autos mit mehr als 5 Zylinder & > 100 PS aus
head(subset(mtcars,
       subset = cyl > 5 &
                hp > 100), 5) 
# Wähle nur Autos mit mehr als 5 Zylinder & > 100 PS aus & dabei weniger als 15 Meilen pro Gallone fahren
head(subset(mtcars,
       subset = cyl > 5 &
                hp > 100 &
                mpg < 15), n = 5)
```

Wenn ihr also mit richtigen (unter heutigen Gesichtspunkten) Drecksschleudern rumfahren wollt, dann habt ihr durch logisches Filtern eine gute Auswahl getroffen. Diese fünf Autos erfüllen unsere drei gesetzten Kriterien. 

Hier findet ihr eine Auflistung der logischen Operatoren in R:

|Logischer Operator | Bedeutung|
|:--|:--|
|`==`   |Gleich|
|`!=`   |Nicht gleich|
|`<`    |Kleiner als|
|`<=`   |Kleiner als oder gleich|
|`>`    |Größer als|
|`>=`   |Größer als oder gleich|
|`|`    |Oder|
|`!`    |Nicht|
|`%in%` |Durchsuche in|

Mit der Hilfe von `&` (**UND**), `|` (**ODER**), `%in%` (**VIELE ODER ARGUMENTE**) können Abfragen wie `>` oder `<` ergänzt werden. 

## Erstellen von eigenen Funktionen

Wie wir einzelne Funktionen (bspw. `mean()` und `sd()`) anwenden haben wir bereits gelernt. Wir können aber auch selber eine Anwendung oder Funktion schreiben, in der mehrere Funktionen gebündelt sind. Viele Schritte in der Datenaufbereitung und Analyse wiederholen sich ständig. Daher ist es sinnvoll bestimmte Schritte zu "automatisieren". Wollen wir zum Beispiel statistische Werte zum `mtcars` Datensatz haben, so können wir jeden Wert einzeln abfragen mit 

```{r}
length(mtcars$hp) # Anzahl der Werte
mean(mtcars$hp) # Arithmetisches Mittel
sd(mtcars$hp) # Standardabweichung
min(mtcars$hp) # Minimum
max(mtcars$hp) # Maximum
median(mtcars$hp) # Median
```

Eine Möglichkeit wiederholte Abfragen zu ermöglichen ist das Ablegen in einen einzelnen Vektor:

```{r}
mtcars_hp_descriptives <- c(
  n = length(mtcars$hp),
  mean = mean(mtcars$hp),
  sd = sd(mtcars$hp),
  min = min(mtcars$hp),
  max = max(mtcars$hp),
  median = median(mtcars$hp)
)

mtcars_hp_descriptives
```

Et voila 🎉 Eingabe des Objektes `mtcars_hp_descriptives` ermöglicht es uns die statistischen Kennwerte direkt auszugeben. Im `mtcars` Datensatz gibt es aber noch weitere Kenndaten. Wie können wir den code so anpassen, dass wir nicht jedes mal alles wieder neu abtippen müssen. Es wäre doch zu schön wenn so etwas in R möglich ist. Zwei Argumente warum ihr euch bei diesen Schritten gut überlegen solltet eine Funktion zu schreiben:

* Anstatt mehrerer Codezeilen ist in Zukunft für dasselbe Ergebnis eine Codezeile – der Funktionsaufruf – erforderlich.
* Der Code bzw. euer Skript wird weniger redundant und übersichtlicher
* Fehlerkorrekturen und Anpassungen werden vereinfacht, da ihr nur die Funktion ändern müsst und nicht jedes mal die Stellen wo die Funktion auftritt. 

Funktionen in R sind Objekte und werden ebenfalls mit dem `<-` zugewiesen. Das Schema ist dabei immer das folgende mit drei zentralen Komponenten:

* Funktionsargumente, wie bei unseren bisherigen Funktionen auch (bspw. `na.rm = TRUE`)
* Body der Funktion, welcher den Code zum Ausführen enthält
* environment, beinhaltet die Datenstruktur damit die Funktion einen Wert mit dem Namen assoziieren kann


```{r eval = F}
funktionsname <- function(argument_1, argument_2) {
  # Body: Code, der ausgeführt wird
}
```

Mit der Funktion `function()` weisen wir einem Objektnamen ein Funktionsobjekt zu. Um den Code auf eine andere Variable anzuwenden, müssten wir jeweils `mtcars$hp` ersetzen – z. B. durch `mtcars$cyl` oder eine Variable aus einem anderen Datensatz. Wir möchten diesen Teil also durch einen Platzhalter ersetzen, den wir dann als Funktionsargument übergeben können. Mit einem generischen Platzhalter, den wir der Einfachheit halber als x bezeichnen, sähe der Code also wie folgt aus:

```{r}
descriptives <- function(x) { # Wir definieren 'x' als Argument
  descriptives_vector <- c(
    n = length(x),
    mean = mean(x),
    sd = sd(x),
    min = min(x),
    max = max(x),
    median = median(x)
  )
}
```

Die Funktionsargumente werden in eine runde Klammer geschrieben `()` und der body in eine eckige `[]`. Unter **Environment** taucht unsere Funktion `descriptives` nun bei der Rubrik Funktionen auf und kann im Folgenden eingesetzt werden. 

```{r}
descriptives(mtcars$disp)
```

Komisch das uns die Werte noch nicht angezeigt werden. Dies liegt daran, dass wir abschließend noch definieren müssen, was die Funktion mit der Anfrage durchführen soll. Vereinfacht gesagt, die Werte sollen angezeigt werden.

```{r}
descriptives <- function(x) { # Wir definieren 'x' als Argument
  descriptives_vector <- c(
    n = length(x),
    mean = mean(x),
    sd = sd(x),
    min = min(x),
    max = max(x),
    median = median(x)
  )
  return(descriptives_vector) # oder nur descriptives_vector
}

descriptives(mtcars$cyl)  # Zusammenfassung der Zylinder
descriptives(mtcars$mpg)  # Zusammenfassung des Verbrauchs
descriptives(mtcars$gear) # Zusammenfassung Anzahl der Gänge
```

Falls wir jedoch fehlende Werte `NA`s in unserem Datensatz haben müssen wir die Funktion anpassen, da dies in den Funktionsargumenten momentan noch fehlt. 

```{r}
descriptives <- function(x, na.rm = TRUE) { # Default-Wert für 'na.rm' = TRUE
  descriptives_vector <- c(
    n = length(x),
    mean = mean(x, na.rm = na.rm), 
    sd = sd(x, na.rm = na.rm),     
    min = min(x, na.rm = na.rm),   
    max = max(x, na.rm = na.rm),
    median = median(x, na.rm = na.rm)
  )
  return(descriptives_vector)
}

a <- c(3,6,12,4,NA)
descriptives(a)
```

💡 Anstelle von `TRUE` oder `FALSE` erkennt R auch ein einfaches `T` oder `F`.  

Viele Funktionen haben `default` als vordefinierte Argumente. Diese könnten wir auch in unserer Funktion ergänzen indem wir na.rm `=` setzen:


Dieser Default-Wert wird nun also immer verwendet, wenn wir das Argument nicht angegeben haben. Unsere Funktion ist somit noch flexibler geworden.

### Speziellere Anwendungen von Funktionen

Lasst uns diese Kenntnisse erweitern und unsere Daten mit Statistikparametern plotten:

```{r}
spezialplot <- function(x = rnorm(100),
                        y = rnorm(100),
                        add.mean = FALSE,
                        add.regression = FALSE,
                        p.threshold = .05,
                        add.modeltext = FALSE,
                        ...  # Weitere Argumente die ergänzt werden sollen
                           ) {
# Erstelle den Plot
# und setze ggf. weitere Argumente wie `main` für Titel
  plot(x, y, ...)

# Erstelle Referenzlinie vom Mittelwert wenn add.mean = TRUE
if(add.mean == TRUE) {

  abline(h = mean(y), lty = 2)
  abline(v = mean(x), lty = 2)
}

# Erstelle Regressionlinie wenn add.regression = TRUE
if(add.regression == TRUE) {

  model <- lm(y ~ x) # Erstelle Regression mit `lm` linear model

  p.value <- anova(model)$"Pr(>F)"[1] # Ziehe den p Wert aus dem Objekt p.value

  # Definiere die Farbe in Abhängigkeit von p.value und p.threshold
  if(p.value < p.threshold) {line.col <- "red"}
  if(p.value >= p.threshold) {line.col <- "black"}

  abline(lm(y ~ x), col = line.col, lwd = 2) # Füge die Regressionlinie hinzu

}

  # Add regression equation text if add.modeltext is TRUE
if(add.modeltext == TRUE) {

  # Erstelle Regressionsdaten
  model <- lm(y ~ x)

  # Extrahiere die Koeffizienten vom Objekt `model`
  coefficients <- model$coefficients
  a <- round(coefficients[1], 2)
  b <- round(coefficients[2], 2)

  # Create text
  model.text <- paste("Regression Equation: ", a, " + ", b, " * x", sep = "")

  # Add text to top of plot
  mtext(model.text, side = 3, line = .5, cex = .8)

}
}
```

Jetzt können wir in unsere Beispielfunktion Daten einsetzen aus dem `mtcars` Datensatz:

```{r}
spezialplot(x = mtcars$mpg, 
            y = mtcars$hp)
# Das sieht danach aus, dass der Verbrauch größer ist je mehr PS das Auto hat
# Wir können das Überprüfen indem wir die zusätzlichen Argumente in unserer Funktion setzen
spezialplot(x = mtcars$mpg, 
            y = mtcars$hp, 
            add.mean = TRUE, 
            add.regression = TRUE, 
            add.modeltext = TRUE, 
            p.threshold = .05, 
            xlab = "Miles per gallon",
            ylab = "Horsepower")

# Und wie schaut das ganze für Gewicht und Verbrauch aus
spezialplot(x = mtcars$mpg, 
            y = mtcars$wt, 
            add.mean = TRUE, 
            add.regression = TRUE, 
            add.modeltext = TRUE, 
            p.threshold = .05, 
            xlab = "Miles per gallon",
            ylab = "Weight (1000 lbs)")
```

Schnelle Analyse: Je mehr Pferdestärken und je größer das Gewicht, desto größer ist auch der Verbrauch des Autos. 

💡 Anstelle eine Funktion immer wieder aufs neue zu schreiben empfiehlt es sich ein R Skript anzulegen unter File -> New File -> R script. Hier könnt ihr eure Funktionen reinschreiben, in eurem Projektordner hinterlegen und mit der Funktion `source` automatisch in eure aktuelle R session hineinladen. Das spart Platz und beschleunigt eure explorative Datenanlyse erheblich. 

```{r}
# Evaluiere den Code in meinem `custom_function` script zu Beginn meiner Session
source(file = "custom_functions.R")
```

### Nutze `...` als Platzhalter

Wenn man nicht alle Argumente in einer Funktion definieren möchte, sich dieses aber noch für später offen lassen möchte:

```{r}
descriptives <- function(x, ...) { # Here is where the additional arguments go
  descriptives_vector <- c(
    n = length(x),
    mean = mean(x, ...), # and here
    sd = sd(x, ...),     
    min = min(x, ...),   
    max = max(x, ...),
    median = median(x, ...)
  )
  return(descriptives_vector)
}

a <- c(3,6,12,4,NA)
descriptives(a, na.rm = T)
```