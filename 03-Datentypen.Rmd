# Grundlagen

*Der Beitrag wurde das letzte mal am `r format(Sys.time(), '%d %B, %Y')` editiert*

```{r include=FALSE}

knitr::opts_chunk$set(fig.align = "center", collapse = T, echo = TRUE, message = FALSE, warning = FALSE)

# With collapse = TRUE the Source and output lived together happily ever in knitr.
# https://github.com/yihui/knitr-examples/blob/master/039-merge.md

# loading multiple packages at once with `pacman`
# create a vector name
packages <- c("tidyverse", "markdown", "knitr", "matrixStats", "patchwork", "lubridate", "plotly",  "naniar", "stlplus", "gt", "dygraphs", "htmltools", "zoo", "xts", "ggpmisc", "forcats", "RColorBrewer", "Kendall", "rstudioapi", "multcompView", "plyr", "bookdown", "janitor")
 
# Load the packages vector 
pacman::p_load(packages, character.only = T)


my_theme <- theme(
  panel.background = element_rect(fill = "white", color = "black"),
  panel.grid.major = element_blank(), 
  panel.grid.minor = element_blank(), 
  panel.border = element_blank())

```

Im folgenden lernen wir mehr zu Datentypen in R und welche Rolle sie spielen. Ganz grundlegend lassen sich verschiedene Strukturen unterscheiden [Zusammenfassung](https://statsandr.com/blog/variable-types-and-examples/):

```{r echo=FALSE, fig.cap="Grundlegende Datenstruktur"}
knitr::include_graphics("images/013a.png")
```

* **Quantitative Variablen** sind nummerisch und k√∂nnen gemessen werden
    + **Diskret** z√§hlbar mit einer finiten Anzahl an M√∂glichkeiten
        -   Anzahl Kinder einer Familie
        -   Studenten in einem Klassenzimmer
        -   Br√∂tchen in einer T√ºte
    + **Kontinuierlich** nicht-z√§hlbar mit einer infiniten Anzahl an M√∂glichkeiten
        -   Alter (e.g. ein 28-j√§hriger Mann kann spezifischer ausgedr√ºckt 28 Jahre, 7 Monate, 16 Tage, 3 Stunden, 4 Minuten, 5 Sekunden, 31 Milisekunden, ... alt sein. Alle Messungen stoppen per Konvention bei einem gewissen Level an Pr√§zision, was uns aber nicht stoppen muss h√∂heraufl√∂send zu messen. Dies bedingt das unser Messwert eine infinite Anzahl an M√∂glichkeiten aufweisen kann.
        - Gewicht
        - Gr√∂√üe

* **Qualitative Variable** oder kategorische Variable (factor in R) sind nicht-numerisch und die Werte passen in eine Kategorie
    + **Nominal** keine Hierarchie oder Ordnung in den Werten (e.g. Geschlecht (m√§nnlich/weiblich) hat keine interne Struktur
    + **Ordinal** hat eine interne Ordnung (e.g. Gesundheitsstatus differenziert nach schlecht/m√§√üig/gut/hervorragend)
    
```{r echo=F, fig.cap="Illustration von @allison_horst: https://twitter.com/allison_horst"}
knitr::include_graphics("images/018.png")
```

```{r echo=F, fig.cap="Illustration von @allison_horst: https://twitter.com/allison_horst"}
knitr::include_graphics("images/019.png")
```

## Datentypen

Im folgenden werden die vier grundlegenden **Datentypen** (*atomic vectors*) behandelt:

* `logical` (TRUE, FALSE)
* `integer` (c(1, 2.4, 4.678))
* `double` (auch als `numeric` bezeichnet; c(1L, 2L, 3L))
* `character` (c("these are", "some strings"))

```{r echo=FALSE, fig.cap="Atomic vectors, source: https://adv-r.hadley.nz/vectors-chap.html"}
knitr::include_graphics("images/079.png")
```


Diese Datentypen k√∂nnen in Form bestimmter Datenstrukturen miteinander verkn√ºft werden. In R ist dies √ºber die Dimensionalit√§t der Daten definiert mit den f√ºnf h√§ufigsten Strukturen:

|  |Homogen|Heterogen|
|:--|:--|:--|
|1d|Atomic vector|List|
|2d|Matrix|Data frame|
|nd|Array||

Table: Datenstrukturen in R

üîç [Advanced R by Hadly Wickham](https://adv-r.hadley.nz/)

### Numerische Objekte

Zahlenwerte in R werden als `numeric` bezeichnet mit der Unterteilung in `integer` (ganze Zahlen) oder `double` (Dezimalzahlen). Die Zuweisung von R, selbst wenn ich eine ganze Zahl zuweise, ist jedoch vom Typ double. 

```{r}
a <- 4
typeof(a)
```

üí° Mit der Funktion `typeof()` kann der Objekttyp erfragt werden.

Um eine ganze Zahl wiederzugeben muss ein L hinter die Zahl gesetzt werden. 

```{r}
a <- 4L
typeof(a)
```

### Textobjekte 

Ein `character` Objekt sind Namen wie `"Kristof"`, `"Tim"`, `"Beste Norddeutschland Exkursion der Welt"` (Textvariablen werden auch als *string* bezeichnet). Um ein `character` Objekt zu definieren sind die Anf√ºhrungsstriche als einfache `' '` oder doppelte `" "` Anf√ºhrungszeichen wichtig!

```{r}
# Dies sind alles character Objekte 
"Kristof"
"Tim"
"Beste Norddeutschland Exkursion der Welt"
```

Bestimmte Funktionen brauchen einen numerical input, wohingegen andere einen character input ben√∂tigen. Schaue was passiert:

```{r eval = F}
mean(c("5", "1"))
```

**Warnmeldung:In mean.default(c("5", "1")) :Argument ist weder numerisch noch boolesch: gebe NA zur√ºck**

Lasse ich die Anf√ºhrungsstriche weg, dann ist wieder alles im Lot:

```{r}
mean(c(5, 1))
```

### Logicals 

Der dritte wichtige Objekttyp in R lautet `logical` und dieser kann zwei Werte annehmen: `TRUE` (wahr) und `FALSE` (falsch). Logicals entstehen durch den logischen Vergleich zwischen zwei Werten oder den Elementen eines Vektors. Operatoren die f√ºr diese Anfrage genutzt werden k√∂nnen lauten:

|Operator | Bedeutung | Beispiel |
|:---|:---|:---|
| == | ist gleich                       | 1==1 (ergibt `TRUE`) "a"=="b" (ergibt `FALSE`) |
| != | ist nicht gleich                 | 1 != 1 (ergibt `FALSE`) "a" != "b" (ergibt `TRUE`) |
| <  | ist kleiner als                  | 1 < 2 (ergibt `TRUE`) 2 < 2 (ergibt `FALSE`) |
| >  | ist gr√∂√üer als                   | 2 > 1 (ergibt `TRUE`) 2 > 2 (ergibt `FALSE`) |
| <= | ist kleiner gleich               | 1 <= 2 (ergibt `TRUE`) 2 <= 2 (ergibt `TRUE`) |
| >= | ist gr√∂√üer gleich                | 2 >= 1 (ergibt `TRUE`) 2 >= 2 (ergibt `TRUE`) |

Table: Logische Operatoren in R.

### Fehlende Werte

In R werden fehlende Werte mit `NA` f√ºr `not available` gekennzeichnet. F√ºr bestimmte Funktionen und Anwendungen ist es wichtig, falls ein `NA` Wert in einer Zeitreihe auftritt (ü§Ø ...leider ist dies in langen Zeitreihen fast immer der Fall), R explizit zu sagen was mit diesen Werten getan werden soll. 

```{r}
# Ich habe einen Vektor mit einem fehlenden Wert NA
a <- c(1,2,3,4,NA,5)
mean(a)
```
Hm...der Mittelwert von 1,2,3,4,NA und 5 ist NA und nicht eine Zahl? Wie kommt das blo√ü. In dem Fall ist es n√ºtzlich in die Dokumentation der Funktion `mean()` nachzuschauen. 

```{r eval = F}
?mean
```

**Default S3 method: mean(x, trim = 0, na.rm = FALSE, ...)**

Die default Argumente der Funktion lauten `na.rm = FALSE`, was soviel bedeutet **na** Werte nicht zu entfernen sondern in die Berechnung mit einzubeziehen. 

üí° na steht f√ºr fehlende Werte (NA) und rm ist die Kurzform f√ºr remove, also entfernen. 

Damit unsere Rechnung funktioniert m√ºssen wir in der `mean()` Funktion das Argument `na.rm = TRUE` setzen, also erst die fehlende Werte entfernen und dann den Mittelwert berechnen:

```{r}
mean(a, na.rm = TRUE)
```
üí™ Es funktioniert! Dies ist tats√§chlich einer der h√§ufigsten Fehler und egal wie h√§ufig man daran denkt, es kommt immer wieder vor das dies einer der Gr√ºnde ist warum man sich Stunden den Kopf √ºber ein nicht funktionierendes Skript zerbricht ü§Ø

### Weitere Objekttypen

Neben den drei vermeintlich wichtigsten Objekttypen (`numeric`, `character`, `logical`) gibt es in R noch die Typen f√ºr 

* Kategoriale Variablen `factor`
* Datumsangaben `date`
* Datumsangaben + Zeit `datetime` 
* ... und weitere

Wenn man Daten in R einliest muss man R jedoch einen Schubser geben, damit eine Spalte bspw. auch als `date`erkannt wird und nicht als `character` oder `numeric`. Wie man dies ber√ºcksichtigt lernen wir in dem Kapitel **Daten einlesen**. 

#### S3 Objekte

Vektoren in R weisen verschiedene Attribute auf. Die zwei wichtigsten Attribute sind:

* dimension (wandelt einen Vektor in eine Matrix oder Liste um)
* class (bedient S3 Objekte, bspw. `factor`, `date` und `POSIXct`)

Wenn ein Objekt in R ein *class* Attribut besitzt wird es automatisch in ein **S3 object** umgewandelt und unterscheidet sich dadurch von einem normalen Vektor. 

```{r echo=F, fig.cap="S3 atomic vectors, source: https://adv-r.hadley.nz/vectors-chap.html#s3-atomic-vectors"}
knitr::include_graphics("images/080.png")
```

`factor` sind bspw. aufgebaut aus den Attributen `class` und `levels` um kategorische Daten zu speichern. 

### Objekttypen √§ndern

Die Syntax in R um Objekte umzuwandeln lautet `as.[Objekttyp]`.

```{r}
a <- "25"
typeof(a)
a <- as.numeric(a)
typeof(a)
```

Dies klappt allerdings nur, insofern die Umwandlung logisch ist. In allen anderen F√§llen gibt es eine Warnmeldung unter Erzeugung von `NA`s anstelle der Werte. 

```{r eval = F}
a <- as.numeric("Beste Norddeutschland Exkursion der Welt")
```

**## Warning: NAs introduced by coercion**

## Datenstrukturen

```{r echo=F, fig.cap="Vergleich eines Skalars und eines Vektors", out.width="50%"}
knitr::include_graphics("images/015.png")
```

Der einfachste Datentyp in R ist ein Skalar ([Mathematische Gr√∂√üe, die allein durch die Angabe eines *Zahlen*wertes charakterisiert ist](https://de.wikipedia.org/wiki/Skalar_(Mathematik))). Im Gegensatz zu der mathematischen Beschreibung, kann in R ein Skalar jedoch `character` sein und muss nicht zwangsl√§ufig als `numeric` definiert sein. Mathematische Operationen sind mit `numerischen` Skalaren m√∂glich, nicht jedoch wenn diese in R als `character` gespeichert sind. 

```{r eval = F}
a <- "1"
b <- "2"
a + b
```

**Fehler in a + b : nicht-numerisches Argument f√ºr bin√§ren Operator**

Bisher haben wir einfache Objekte in R erzeugt, wie eben genau Skalare oder k√ºrzere Vektoren. Es gibt jedoch noch weitere Datenstrukturen, die sich hinsichtlich der Dimensionalit√§t unterscheiden (1D und 2D) und ob die Objekttypen homogen (nur ein Objekttyp) und heterogen (unterschiedliche Objekttypen) beinhalten:

|Datenstruktur |	Dimensionalit√§t |	Objekttypen|
|Vektor |	eindimensional |	homogen|
|Liste |	eindimensional 	|heterogen|
|Matrix |	zweidimensional |	homogen|
|Dataframe |	zweidimensional 	|heterogen|

Table: Datenstrukturen in R. 

### Vektor 

Ein Vektor ist eine Ansammlung von Skalaren, die als ein R Objekt gespeichert wurden. Die Zahlen von 1 bis 10 bspw. bilden einen numerischen Vektor mit der L√§nge 10. Die Buchstaben im Alphabet sind ein Vektor mit der L√§nge 26. 

üö® Vektoren k√∂nnen nur `numeric` **oder** `character` sein...nicht beides!

Es gibt verschiedene M√∂glichkeiten einen Vektor selber zu bilden. 


| Funktion| Beispiel|Ergebnis|
|:--|:--|:--|
|`c(a, b, ...)`|`c(1, 5, 9)`|`r c(1, 5, 9)`|
|`a:b`|`1:5`|`r 1:5`|
|`seq(from, to, by, length.out)`|`seq(from = 0, to = 6, by = 2)`|`r seq(from = 0, to = 6, by = 2)`|
|`rep(x, times, each, length.out)`|`rep(c(7, 8), times = 2, each = 2)`|`r rep(c(7, 8), times = 2, each = 2)`|

Table: Funktionen um einen Vektor zu erzeugen.

Die einfachste M√∂glichkeit einen Vektor zu erzeugen ist mit der `c()` Funktion. "c" leitet sich von dem englischen Wort concatenate ab und l√§sst sich frei √ºbersetzen mit "zusammenbringen" oder "zusammenf√ºhren". 

```{r echo = T}
# Speichere einen Vektor mit den Zahlen von 1 bis 10 
a <- c(1,2,3,4,5,6,7,8,9,10)
# Stelle die Zahlen dar
a
```

Man kann auch Vektoren miteinander verkn√ºpfen:

```{r echo = T}
a <- c(1,2,3,4,5)
b <- c(6,7,8,9,10)
x <- c(a, b)
x
```

üòé Yeah! Das hat ja gut geklappt. 

Man kann auch `character` Vektoren erstellen mit demselben Prinzip

```{r echo = T}
wort_vec <- c("Beste", "Exkursion", "der", "Welt")
wort_vec
```

Wenn ihr allerdings einen Vektor von 1:1000 erstellen wollt... ü§Ø
Aber keine Sorge! Auch hierf√ºr gibt es Funktionen in R um das Leben zu erleichtern. 

#### a:b

Die Vektoren werden in Inkrementen von 1 aufgef√ºllt 

```{r echo = T}
1:10
# Das ganze geht auch R√ºckw√§rts
10:1
# Oder mit nicht runden Zahlen (non-integers)
2.5:8.5
```

#### seq()

Diese Funktion musste ich f√ºr Zeitreihenuntersuchungen schon √∂fter verwenden und ist ein wahrer Retter in der Not.

| Argument| Definition|
|:-------------------------|:-----------------------------|
|     `from`|    Beginn der Sequenz |
|     `to`|     Ende der Sequenz |
|     `by`|    Die Inkremente|
|     `length.out`|   Die gew√ºnschte L√§nge der Sequent (nur wichtig wenn `by` festgelegt wurde)|

```{r echo = T}
# Erstelle Nummer von 1 bis 10 in einer Schritten
seq(from = 1, to = 10, by = 1)
# Erstelle ganze Zahlen von 0 bis 100 in 10er Schritten
seq(from = 0, to = 100, by = 10)
```

Wenn das Argument `length.out` verwendet wird, entspricht die L√§nge des Vektors dem Wert von `length.out`. 

```{r echo = T}
# Erstelle 10 Zahlen von 1 bis 5
seq(from = 1, to = 5, length.out = 10)
# Erstelle 3 Zahlen von 0 bis 100
seq(from = 0, to = 100, length.out = 3)
```

#### rep()

| Argument| Definition|
|:-------------------------|:-----------------------------|
|     `x`               | Ein Skalar oder Vektor der wiederholt werden soll |
|     `times`           | Die Anzahl wie h√§ufig `x` wiederholt werden soll |
|     `each`            | Die Anzahl wie h√§ufig jeder Wert in `x` wiederholt werden soll|
|     `length.out`      | Die gew√ºnschte L√§nge der Sequenz|

Die rep() Funktion erlaubt es also einen Skalar oder Vektor beliebig oft zu wiederholen. 

```{r echo = T}
rep(x = 3, times = 10)
rep(x = c(1, 2), each = 3)
rep(x = 1:3, length.out = 10)
```

üí° Man kann eine `a:b` Funktion mit einer `rep()` Funktion verkn√ºpfen.
üí° Sogar das `times` und `each` Argument lassen sich in die `rep()` Funktion integrieren

```{r echo = T}
rep(x = 1:3, each = 2, times = 2)
```

#### Vektorelemente ausw√§hlen

Um auf eine Zahl in einem Vektor zuzugreifen k√∂nnen wir dies √ºber eine eckige Klammer `[]` tun. 

```{r}
a <- c(1,2,3,4,5)
a[2]
a[5]
```

Wenn wir mehrere Elemente des Vektors ausw√§hlen m√∂chten, dann m√ºssen wir einen neuen Vektor √ºber die Positionen erzeugen, beispielsweise um das erste, dritte und f√ºnfte Element des Vektors auszugeben:

```{r}
a[c(1,3,5)]
```

Eine weitere M√∂glichkeite die ersten drei Elemente eines Vektors auszuw√§hlen ist mit dem Doppelpunkt `:` was so viel bedeutet wie *von bis*. 

```{r}
a[1:4]
```

Elemente in einem Vektor k√∂nnen auch mit `=` benannt werden. Bei der Benennung von Spaltennamen in einer Tabelle (dataframe oder Matrix in R) ist der Befehl √§hnlich. 

```{r}
namen <- c(eins = "Dies", zwei = "ist", drei = "ein", vier = "Test")
namen
namen["vier"]
```

### Liste

Listen √§hneln Vektoren und k√∂nnen √ºber die Funktion `list()` erzeugt werden. Beispielsweise der Standort Speicherkoog kann als Liste wie folgt erzeugt werden:

```{r}
koog <- list(country = "Germany", state = "Schleswig-Holstein", city = "Meldorf", name = "Speicherkoog")
koog
```

Die Darstellung gegen√ºber Vektoren ist jedoch eine andere. Anstelle der Darstellung nebeneinander werden die Listen Elemente untereinander dargestellt. 

### Matrix und dataframe

```{r echo=F, fig.cap="Darstellung von Datenstrukturen", out.width="50%"}
knitr::include_graphics("images/020.png")
```


#### Matrix

Eine Matrix ist eine zweidimensionale Struktur und kann mit der Funktion `matrix()` erzeugt werden. 

```{r}
# Erstelle einen Vektor von 1 bis 10
a <- c(1:10)
# Teile den Vektor auf zwei Spalten auf
b <- matrix(a, ncol = 2)
b
# Teile den Vektor auf zwei Zeilen auf
c <- matrix(a, nrow = 2)
c
```

Mit der Funktion `rbind()` (row = Zeile) oder `cbind()` (column = Spalte) k√∂nnen wir mehrere Vektoren auch zusammenf√ºhren. 

```{r}
a <- c(1:10)
b <- c(11:20)
c <- c(21:30)
# Erstelle eine Matrix mit drei Spalten
cbind(a,b,c)
# Erstelle eine Matrix mit drei Zeilen
rbind(a,b,c)
```

Die Spalten- oder Zeilennamen einer Matrix k√∂nnen auch benannt oder umbenannt werden mit der Funktion `colnames()` oder `rownames()`.

```{r}
mat <- rbind(a,b,c)
mat
rownames(mat) <- c("Zeile 1", "Zeile 2", "Zeile 3")
mat
```

Eine n√ºtzliche Funktion lautet `t()` um eine Matrix oder dataframe zu **transponieren**, also umzuwandeln und um 90¬∞ zu vertauschen.

```{r}
# Transponiere die Matrix mat 
t(mat)
```

Unsere Zeilennamen machen jetzt nat√ºrlich keinen Sinn mehr üôÉ Versuche mal die Spaltennamen richtig zu beschriften. 

#### Dataframe

Eine Matrix √§hnelt der Datenstruktur wie man sie aus Excel, SPSS etc. kennt. Gro√üer Unterschied ist aber, dass eine Matrix nur **einen** Datentyp erlaubt und ein dataframe **mehrere** Typen. Mit der Funktion `data.frame()` k√∂nnen wir gleich lange Vektoren unterschiedlichen Typs kombinieren.

```{r}
# Erstelle einen dataframe
beatles_data <- data.frame(
  name = c("John", "Paul", "George", "Ringo"),
  surname = c("Lennon", "McCartney", "Harrison", "Starr"),
  born = c(1940, 1942, 1943, 1940)
)
beatles_data
```

Die h√§ndische Eingabe von tabellarischen Daten w√§re nat√ºrlich umst√§ndlich. In R gibt es einfache M√∂glichkeiten diese aus externen Datenquellen (z.B. CSV, Excel, txt, ...) einzulesen und zu verarbeiten. 

#### tibble

`tibble` haben dieselbe Datenstruktur wie `data.frame`, nur das Attribut `class` in einem tibble ist l√§nger:

```{r}
# create a data frame
df1 <- data.frame(
  x = c("a", "b", "c"),
  y = c(1,2,3)
)
typeof(df1)
attributes(df1)

# create a tibble
df2 <- tibble(
  x = c("a", "b", "c"),
  y = c(1,2,3)
)
typeof(df2)
attributes(df2)

```




## Zufallszahlen erzeugen

R ist eine Statistiksprache und da w√§re es doch verwunderlich wenn es nicht auch Funktionen gibt, um Zufallszahlen zu erzeugen. F√ºr Vektoren ist dies die Funktion `sample()`:

| Argument| Definition|
|:---------|:---------------------------------------------|
|     `x`|    Ein Vektor (character oder numeric) von dem die Zufallszahlen erzeugt werden.|
|     `size`|     Die Anzahl der Zufallszahlen. Der Standard (default) ist die L√§nge des Vektors `x`.|
|     `replace`|    Standard ist `FALSE`. Bei `TRUE` kann die Zahl mehrmals vorkommen.|
|     `prob`|   Ein Vektor der M√∂glichkeiten f√ºr `x` mit der Wahrs `x` is. The vector of probabilities you give as an argument should add up to one. If you don't specify the `prob` argument, all outcomes will be equally likely.|

```{r echo = T}
# Die Zahlen 1 bis 5 treten nur einmal auf
sample(x = 1:5, size = 5)
# Die Zahlen 1 bis 5 k√∂nnen ggf. mehrmals auftreten hei replace = TRUE
sample(x = 1:5, size = 5, replace = T)
```

```{r echo=F, fig.cap="Illustration von @allison_horst: https://twitter.com/allison_horst"}
knitr::include_graphics("images/017.png")
```


Die erzeugten Zufallsvariablen k√∂nnen dabei **normalverteilt** oder **nicht-normalverteilt** sein. Es gibt jedoch noch eine Vielzahl weiterer Funktionen in R, die mit dem help Befehl aufgerufen werden k√∂nnen

```{r eval = F, echo = T}
?Distributions
```

Die normale Standardverteilung (auch bekannt unter Gausssche Normalverteilung) kann mit der Funktion `rnorm` erzeugt werden. Es k√∂nnen dabei die folgenden Argumente gesetzt werden. 

| Argument| Definition|
|:---------|:---------------------------------------------|
|     `n`|     Stichprobenanzahl.|
|     `mean`|      Mittelwert der Verteilung.|
|     `sd`|     Standardabweichung der Verteilung.|

```{r echo = T}
# Erstelle 100000 Zahlen mit dem Mittelwert 10 und der Standardverteilung 3
a <- rnorm(n = 100000, mean = 10, sd = 3)
a <- as.data.frame(a)
# Erstelle zwei weitere Spalten. Selber Mittelwert aber unterschiedliche SD 
# Keine Sorge! Was das komische Symbol %>% bedeutet lernen wir sp√§ter
colnames(a) <- c("norm_3")
a <- a %>%
    mutate(norm_1 = rnorm(n = 100000, mean = 10, sd = 1)) %>%
    mutate(norm_0.5 = rnorm(n = 100000, mean = 10, sd = 0.5)) %>%
    pivot_longer(cols = everything())
# Erstelle die Abbildung mit ggplot...keine Sorge. Die Power von ggplot lernt ihr sp√§ter kennen. 
a %>%
    ggplot(aes(x = value, color = fct_reorder(.f = name, .x = value, .fun = max))) +
    geom_density(alpha = 0.1) +
    scale_color_discrete(name = "Standardabweichung") +
    my_theme
```

Das Erzeugen der Daten ist spielend leicht. Plotten der Daten vermittelt weiterhin einen Eindruck davon, wie die Dichteverteilung der Daten variiert bei gleichem `mean()` aber unterschiedlicher `sd()`. 
Was sagt euch die Stichprobenanzahl √ºber das Aussehen der Kurve aus?

```{r echo = T}
# Normalverteilung bei 10 Zufallszahlen
a <- rnorm(n = 10, mean = 10, sd = 3) %>% as.data.frame()
p1 <- a %>%
    ggplot(aes(x = .)) +
    geom_density(alpha = 0.1) +
    labs(
        title = "n = 10"
    ) +
    geom_vline(aes(xintercept = mean(.)), color = "red") +
    my_theme
# Normalverteilung bei 100 Zufallszahlen
a <- rnorm(n = 100, mean = 10, sd = 3) %>% as.data.frame()
p2 <- a %>%
    ggplot(aes(x = .)) +
    geom_density(alpha = 0.1) +
    labs(
        title = "n = 100"
    ) +
    geom_vline(aes(xintercept = mean(.)), color = "red") +
    my_theme
# Normalverteilung bei 100.000 Zufallszahlen
a <- rnorm(n = 100000, mean = 10, sd = 3) %>% as.data.frame()
p3 <- a %>%
    ggplot(aes(x = .)) +
    geom_density(alpha = 0.1) +
    labs(
        title = "n = 100.000"
    ) +
    geom_vline(aes(xintercept = mean(.)), color = "red") +
    my_theme

p1 + p2 + p3
```

üö® Jedes mal wenn das Skript neu ausgef√ºhrt wird, √§ndern sich auch die Zufallszahlen. 

## Rechnen mit Vektoren

Es lassen sich mit Vektoren mathematische Operationen und zusammenfassende Statistiken durchf√ºhren. Im folgenden wollen wir Redoxpotenziale umrechnen, welche mit einer Silber-Silberchlorid Elektrode gemessen wurden. F√ºr die Vergleichbarkeit und korrekte Nomenklatur sollten die Werte jedoch immer gegen die Standardwasserstoffelektrode (SHE) angegeben werden. Das Potenzial der SHE ist bei 25 ¬∞C um +207 mV gr√∂√üer, als das der Ag-AgCl Elektrode. Was m√ºssen wir also tun? Wir m√ºssen auf jeden Wert +207 mV addieren. Kein Problem in R:

```{r echo = T}
# Ein Vektor mit gemessenen Redoxpotenzialen einer Ag-AgCl Elektrode
# Die Funktion `runif()` erzeugt Werte mit einer stetigen Gleichverteilung zwischen min() und max()
e_agcl <- runif(n = 100, min = 400, max = 500)
# Addition von +207 mV auf jeden Wert des Vektors 
eh <- e_agcl + 207
# Erstelle einen data frame aus den beiden Vektoren 
df <- data.frame(e_agcl, eh) 
df <- df %>%
    mutate(n = seq(from = 1, to = nrow(df))) %>% 
    pivot_longer(cols = c("e_agcl", "eh"))
# Plotte die Darstellung
df %>%
    ggplot(aes(n, value, color = name)) +
    geom_line() +
    labs(
        title = "Verlauf der Redoxpotenziale (korrigiert und unkorrigiert)", 
        x = "Zeit", 
        y = expression(paste("E"[H], " (mV)"))
    ) +
    coord_cartesian(ylim = c(0, 800)) +
    my_theme
```

Wenn wir mathematische Berechnungen mit einem Skalar an einem Vektor durchf√ºhren (in unserem Fall +207 mV), dann f√ºhrt R die Berechnung f√ºr jedes Element des Vektors durch. Es ist nicht nur Addition m√∂glich, sondern auch Subtraktion, Multiplikation und Division. Selbst logarithmieren und entlogarithmieren etc. ist kein Problem. 

Eine Zusammfassung der m√∂glichen Operationen seht ihr unten:

| Funktion| Beispiel|Ergebnis |
|:-------------------|:----------------------|:-----------------------|
|     `sum(x), product(x)`|    `sum(1:10)` |`r sum(1:10)`     |
|     `min(x), max(x)`|    `min(1:10)`|`r min(1:10)`    |
|     `mean(x), median(x)`|    `mean(1:10)`     | `r mean(1:10)` |
|     `sd(x), var(x), range(x)`|    `sd(1:10)` | `r sd(1:10)` |
|     `quantile(x, probs)`|    `quantile(1:10, probs = .2)`|`r quantile(1:10, probs = .2)`     |
|     `summary(x)`|    `summary(1:10)`|`Min = 1.00. 1st Qu. = 3.25, Median = 5.50, Mean = 5.50, 3rd Qu. = 7.75, Max = 10.0`     |

Table: Statistik Funktionen in R.

Lasst uns den Mittelwert und die Standardabweichung des Redoxpotentziales der Zeitreihe berechnen (wenn nicht explizit erw√§hnt beziehe ich mich immer auf den E~H~ Wert in mV gemessen). 

```{r echo = T}
# Mittelwert 
mean(eh)
# SD
sd(eh)
```

Kein Problem mehr f√ºr uns üòé

Vektoren sind simple 1-dimensionale Objekte in R. Wir haben jedoch auch schon Objekte wie Matrix, dataframe oder Listen kennengelernt. Eine grundlegende Sache einer Matrix oder eines dataframe ist es, dass die Vektoren **diesselbe** L√§nge haben m√ºssen! Dies l√§sst sich mit der Funktion `length()` √ºberpr√ºfen. Wie lang war nochmal unser `eh` Vektor?

```{r}
length(eh)
```

Die `length()` Funktion ist nicht die einzige wichtige Funktion um mit Vektoren oder Daten im Allgemeinen zu arbeiten. F√ºr eure Arbeit mit R sind folgende wichtig:

| Funktion| Beschreibung | Beispiel|Ergebnis |
|:------------|:------------------|:-------------------------|:----------|
|     `round(x, digits)`|  Runde Elemente in x zu `digits` Stellen |   `round(c(2.231, 3.1415), digits = 1)` |`r round(c(2.231, 3.1415), digits = 1)`     |
|     `ceiling(x), floor(x)`|  Runde Elemente in x Auf (oder ab) zur n√§chsten ganzen Zahl |  `ceiling(c(5.1, 7.9))`| `r ceiling(c(5.1, 7.9))`|
|     `x %% y`|  Ganzzahlige Division (ie. x durch y) |  `7 %% 3`|`r 7 %% 3` |

## str() Funktion

Eine wichtige Funktion um Informationen √ºber einen Datensatz oder ein Objekt zu bekommen ist die Funktion `str()`, kurz f√ºr **structure**. Diese Funktion l√§sst sich auf alle Datenstrukturen in R anweden, also f√ºr Vektoren, Listen, Matrix und dataframes. 

```{r}
# Erkunden eines Vektors mit 100 Zufallszahlen
str(eh)
```

Hier kann man folgende Informationen draus ablesen:

* Es handelt sich um ein `numeric` Datenformat
* Der Vektor hat 100 Elemente von 1 bis 100
* Die ersten f√ºnf Zahlen lauten ...

Haben wir ein komplizierteres Objekt wie den mtcars Datensatz wird die `str()` Auflistung etwas komplexer:

```{r}
# Erkunden des Datensatzes mtcars
str(mtcars)
```

Wir k√∂nnen an der Datenstruktur erkennen, dass es sich um einen `data.frame` handelt mit 32 observations von 11 Variablen. Alle haben den Datentyp `numeric`. Die Liste ist jedoch so lang, dass sie nicht komplett dargestellt wird. Wollen wir nur die ersten f√ºnf Eintr√§ge anzeigen geht dies mit der `head()` Funktion und die letzten f√ºnf Eintr√§ge mit der `tail()` Funktion:

```{r}
head(mtcars, n = 5)
tail(mtcars, n = 5)
```

Wenn man den Namen des Datensatzes / Objektes in die Funktion `View()` - V dabei gro√ü geschrieben - eingibt, dann kann man sich den Datensatz auch im Viewer Fenster von R ansehen. 

```{r eval = F}
View(mtcars)
```

## Selektion von Spalten/Zeilen in dataframes 

Man kann auf einen einzelnen Vektor des `mtcars` dataframes zugreifen, indem man den Namen des Datensatzes mit dem `$` und weiterhin mit dem Spaltennamen verkn√ºpft:

```{r}
# Zeige mit die Pferdest√§rken (hp) der Fahrzeuge an
mtcars$hp
```

Das Ergebnis ist ein Vektor, mit dem wir die bekannten Vektorfunktionen anwenden k√∂nnen. Die eckige Zahl zu Beginn der Zeile steht dabei f√ºr das `i`te Element des Vektors. Die Zahl 110 steht also auf der Position (dem Index) [1] und die Zahl 245 and Position [24]. Die Darstellung erleichert es einen √úberblick √ºber die Anzahl an Elementen zu bekommen.  

```{r}
mean(mtcars$hp)
```

Die Autos haben im Mittel also 146 PS, bereits 1974 üòé

Auch mit `[]` kann auf Vektoren in einem dataframe zugegriffen werden. Der Spaltenname muss hierbei jedoch in `""` gesetzt werden. 

```{r}
head(mtcars["hp"], 5)
```

Wenn wir die Position der Spalte `hp` kennen gen√ºgt aber auch die Zahl 

```{r}
head(mtcars[4], 5)
```

Last but not least, eine letzte M√∂glichkeit Daten zu spezifizieren ist durch das Setzen eines Kommas:

```{r}
# W√§hle die ersten zwei Zeilen aus aber ALLE Spalten
head(mtcars[1:2, ], 5)
# W√§hle die ersten zwei Spalten aus aber ALLE Zeilen
head(mtcars[ ,1:2], 5)
```

Der Abschnitt vor dem `,` bezieht sich also auf die *Zeilen* und danach auf die *Spalten*. 

Mit `subset()` kann man noch spezifischer auf den Inhalt eines dataframes zugreifen und auch mit logischen Operatoren arbeiten. Es ist eine der wichtigsten Funktionen um auf Daten zur√ºckzugreifen. 

| Argument| Beschreibung| 
|:------------------------|:-----------------------------|
|     `x`| Name des dataframes| 
|     `subset`| Ein logischer Vektor der Werte die man behalten m√∂chte | 
|     `select`| Die Spalten die man behalten m√∂chte | 

```{r}
# W√§hle nur Autos mit mehr als 5 Zylinder aus
head(subset(mtcars,
       subset = cyl > 5), 5)
# W√§hle nur Autos mit mehr als 5 Zylinder & > 100 PS aus
head(subset(mtcars,
       subset = cyl > 5 &
                hp > 100), 5) 
# W√§hle nur Autos mit mehr als 5 Zylinder & > 100 PS aus & dabei weniger als 15 Meilen pro Gallone fahren
head(subset(mtcars,
       subset = cyl > 5 &
                hp > 100 &
                mpg < 15), n = 5)
```

Wenn ihr also mit richtigen (unter heutigen Gesichtspunkten) Drecksschleudern rumfahren wollt, dann habt ihr durch logisches Filtern eine gute Auswahl getroffen. Diese f√ºnf Autos erf√ºllen unsere drei gesetzten Kriterien. 

Hier findet ihr eine Auflistung der logischen Operatoren in R:

|Logischer Operator | Bedeutung|
|:--|:--|
|`==`   |Gleich|
|`!=`   |Nicht gleich|
|`<`    |Kleiner als|
|`<=`   |Kleiner als oder gleich|
|`>`    |Gr√∂√üer als|
|`>=`   |Gr√∂√üer als oder gleich|
|`|`    |Oder|
|`!`    |Nicht|
|`%in%` |Durchsuche in|

Mit der Hilfe von `&` (**UND**), `|` (**ODER**), `%in%` (**VIELE ODER ARGUMENTE**) k√∂nnen Abfragen wie `>` oder `<` erg√§nzt werden. 

## Erstellen von eigenen Funktionen

Wie wir einzelne Funktionen (bspw. `mean()` und `sd()`) anwenden haben wir bereits gelernt. Wir k√∂nnen aber auch selber eine Anwendung oder Funktion schreiben, in der mehrere Funktionen geb√ºndelt sind. Viele Schritte in der Datenaufbereitung und Analyse wiederholen sich st√§ndig. Daher ist es sinnvoll bestimmte Schritte zu "automatisieren". Wollen wir zum Beispiel statistische Werte zum `mtcars` Datensatz haben, so k√∂nnen wir jeden Wert einzeln abfragen mit 

```{r}
length(mtcars$hp) # Anzahl der Werte
mean(mtcars$hp) # Arithmetisches Mittel
sd(mtcars$hp) # Standardabweichung
min(mtcars$hp) # Minimum
max(mtcars$hp) # Maximum
median(mtcars$hp) # Median
```

Eine M√∂glichkeit wiederholte Abfragen zu erm√∂glichen ist das Ablegen in einen einzelnen Vektor:

```{r}
mtcars_hp_descriptives <- c(
  n = length(mtcars$hp),
  mean = mean(mtcars$hp),
  sd = sd(mtcars$hp),
  min = min(mtcars$hp),
  max = max(mtcars$hp),
  median = median(mtcars$hp)
)

mtcars_hp_descriptives
```

Et voila üéâ Eingabe des Objektes `mtcars_hp_descriptives` erm√∂glicht es uns die statistischen Kennwerte direkt auszugeben. Im `mtcars` Datensatz gibt es aber noch weitere Kenndaten. Wie k√∂nnen wir den code so anpassen, dass wir nicht jedes mal alles wieder neu abtippen m√ºssen. Es w√§re doch zu sch√∂n wenn so etwas in R m√∂glich ist. Zwei Argumente warum ihr euch bei diesen Schritten gut √ºberlegen solltet eine Funktion zu schreiben:

* Anstatt mehrerer Codezeilen ist in Zukunft f√ºr dasselbe Ergebnis eine Codezeile ‚Äì der Funktionsaufruf ‚Äì erforderlich.
* Der Code bzw. euer Skript wird weniger redundant und √ºbersichtlicher
* Fehlerkorrekturen und Anpassungen werden vereinfacht, da ihr nur die Funktion √§ndern m√ºsst und nicht jedes mal die Stellen wo die Funktion auftritt. 

Funktionen in R sind Objekte und werden ebenfalls mit dem `<-` zugewiesen. Das Schema ist dabei immer das folgende mit drei zentralen Komponenten:

* Funktionsargumente, wie bei unseren bisherigen Funktionen auch (bspw. `na.rm = TRUE`)
* Body der Funktion, welcher den Code zum Ausf√ºhren enth√§lt
* environment, beinhaltet die Datenstruktur damit die Funktion einen Wert mit dem Namen assoziieren kann


```{r eval = F}
funktionsname <- function(argument_1, argument_2) {
  # Body: Code, der ausgef√ºhrt wird
}
```

Mit der Funktion `function()` weisen wir einem Objektnamen ein Funktionsobjekt zu. Um den Code auf eine andere Variable anzuwenden, m√ºssten wir jeweils `mtcars$hp` ersetzen ‚Äì z. B. durch `mtcars$cyl` oder eine Variable aus einem anderen Datensatz. Wir m√∂chten diesen Teil also durch einen Platzhalter ersetzen, den wir dann als Funktionsargument √ºbergeben k√∂nnen. Mit einem generischen Platzhalter, den wir der Einfachheit halber als x bezeichnen, s√§he der Code also wie folgt aus:

```{r}
descriptives <- function(x) { # Wir definieren 'x' als Argument
  descriptives_vector <- c(
    n = length(x),
    mean = mean(x),
    sd = sd(x),
    min = min(x),
    max = max(x),
    median = median(x)
  )
}
```

Die Funktionsargumente werden in eine runde Klammer geschrieben `()` und der body in eine eckige `[]`. Unter **Environment** taucht unsere Funktion `descriptives` nun bei der Rubrik Funktionen auf und kann im Folgenden eingesetzt werden. 

```{r}
descriptives(mtcars$disp)
```

Komisch das uns die Werte noch nicht angezeigt werden. Dies liegt daran, dass wir abschlie√üend noch definieren m√ºssen, was die Funktion mit der Anfrage durchf√ºhren soll. Vereinfacht gesagt, die Werte sollen angezeigt werden.

```{r}
descriptives <- function(x) { # Wir definieren 'x' als Argument
  descriptives_vector <- c(
    n = length(x),
    mean = mean(x),
    sd = sd(x),
    min = min(x),
    max = max(x),
    median = median(x)
  )
  return(descriptives_vector) # oder nur descriptives_vector
}

descriptives(mtcars$cyl)  # Zusammenfassung der Zylinder
descriptives(mtcars$mpg)  # Zusammenfassung des Verbrauchs
descriptives(mtcars$gear) # Zusammenfassung Anzahl der G√§nge
```

Falls wir jedoch fehlende Werte `NA`s in unserem Datensatz haben m√ºssen wir die Funktion anpassen, da dies in den Funktionsargumenten momentan noch fehlt. 

```{r}
descriptives <- function(x, na.rm = TRUE) { # Default-Wert f√ºr 'na.rm' = TRUE
  descriptives_vector <- c(
    n = length(x),
    mean = mean(x, na.rm = na.rm), 
    sd = sd(x, na.rm = na.rm),     
    min = min(x, na.rm = na.rm),   
    max = max(x, na.rm = na.rm),
    median = median(x, na.rm = na.rm)
  )
  return(descriptives_vector)
}

a <- c(3,6,12,4,NA)
descriptives(a)
```

üí° Anstelle von `TRUE` oder `FALSE` erkennt R auch ein einfaches `T` oder `F`.  

Viele Funktionen haben `default` als vordefinierte Argumente. Diese k√∂nnten wir auch in unserer Funktion erg√§nzen indem wir na.rm `=` setzen:


Dieser Default-Wert wird nun also immer verwendet, wenn wir das Argument nicht angegeben haben. Unsere Funktion ist somit noch flexibler geworden.

### Speziellere Anwendungen von Funktionen

Lasst uns diese Kenntnisse erweitern und unsere Daten mit Statistikparametern plotten:

```{r}
spezialplot <- function(x = rnorm(100),
                        y = rnorm(100),
                        add.mean = FALSE,
                        add.regression = FALSE,
                        p.threshold = .05,
                        add.modeltext = FALSE,
                        ...  # Weitere Argumente die erg√§nzt werden sollen
                           ) {
# Erstelle den Plot
# und setze ggf. weitere Argumente wie `main` f√ºr Titel
  plot(x, y, ...)

# Erstelle Referenzlinie vom Mittelwert wenn add.mean = TRUE
if(add.mean == TRUE) {

  abline(h = mean(y), lty = 2)
  abline(v = mean(x), lty = 2)
}

# Erstelle Regressionlinie wenn add.regression = TRUE
if(add.regression == TRUE) {

  model <- lm(y ~ x) # Erstelle Regression mit `lm` linear model

  p.value <- anova(model)$"Pr(>F)"[1] # Ziehe den p Wert aus dem Objekt p.value

  # Definiere die Farbe in Abh√§ngigkeit von p.value und p.threshold
  if(p.value < p.threshold) {line.col <- "red"}
  if(p.value >= p.threshold) {line.col <- "black"}

  abline(lm(y ~ x), col = line.col, lwd = 2) # F√ºge die Regressionlinie hinzu

}

  # Add regression equation text if add.modeltext is TRUE
if(add.modeltext == TRUE) {

  # Erstelle Regressionsdaten
  model <- lm(y ~ x)

  # Extrahiere die Koeffizienten vom Objekt `model`
  coefficients <- model$coefficients
  a <- round(coefficients[1], 2)
  b <- round(coefficients[2], 2)

  # Create text
  model.text <- paste("Regression Equation: ", a, " + ", b, " * x", sep = "")

  # Add text to top of plot
  mtext(model.text, side = 3, line = .5, cex = .8)

}
}
```

Jetzt k√∂nnen wir in unsere Beispielfunktion Daten einsetzen aus dem `mtcars` Datensatz:

```{r}
spezialplot(x = mtcars$mpg, 
            y = mtcars$hp)
# Das sieht danach aus, dass der Verbrauch gr√∂√üer ist je mehr PS das Auto hat
# Wir k√∂nnen das √úberpr√ºfen indem wir die zus√§tzlichen Argumente in unserer Funktion setzen
spezialplot(x = mtcars$mpg, 
            y = mtcars$hp, 
            add.mean = TRUE, 
            add.regression = TRUE, 
            add.modeltext = TRUE, 
            p.threshold = .05, 
            xlab = "Miles per gallon",
            ylab = "Horsepower")

# Und wie schaut das ganze f√ºr Gewicht und Verbrauch aus
spezialplot(x = mtcars$mpg, 
            y = mtcars$wt, 
            add.mean = TRUE, 
            add.regression = TRUE, 
            add.modeltext = TRUE, 
            p.threshold = .05, 
            xlab = "Miles per gallon",
            ylab = "Weight (1000 lbs)")
```

Schnelle Analyse: Je mehr Pferdest√§rken und je gr√∂√üer das Gewicht, desto gr√∂√üer ist auch der Verbrauch des Autos. 

üí° Anstelle eine Funktion immer wieder aufs neue zu schreiben empfiehlt es sich ein R Skript anzulegen unter File -> New File -> R script. Hier k√∂nnt ihr eure Funktionen reinschreiben, in eurem Projektordner hinterlegen und mit der Funktion `source` automatisch in eure aktuelle R session hineinladen. Das spart Platz und beschleunigt eure explorative Datenanlyse erheblich. 

```{r}
# Evaluiere den Code in meinem `custom_function` script zu Beginn meiner Session
source(file = "custom_functions.R")
```

### Nutze `...` als Platzhalter

Wenn man nicht alle Argumente in einer Funktion definieren m√∂chte, sich dieses aber noch f√ºr sp√§ter offen lassen m√∂chte:

```{r}
descriptives <- function(x, ...) { # Here is where the additional arguments go
  descriptives_vector <- c(
    n = length(x),
    mean = mean(x, ...), # and here
    sd = sd(x, ...),     
    min = min(x, ...),   
    max = max(x, ...),
    median = median(x, ...)
  )
  return(descriptives_vector)
}

a <- c(3,6,12,4,NA)
descriptives(a, na.rm = T)
```