<<<<<<< HEAD
[["diverses.html", "15.4 Diverses", " 15.4 Diverses Der Beitrag wurde das letzte mal am 26 August, 2021 editiert 15.4.1 Entfernen aller packages Falls es beim arbeiten mit R und den dazugehoerigen packages zu Problemen kommt hilft der folgende Befehl diese zu loeschen: R bloggers # create a list of all installed packages ip &lt;- as.data.frame(installed.packages()) head(ip) # if you use MRO, make sure that no packages in this library will be removed ip &lt;- subset(ip, !grepl(&quot;MRO&quot;, ip$LibPath)) # we don&#39;t want to remove base or recommended packages either\\ ip &lt;- ip[!(ip[,&quot;Priority&quot;] %in% c(&quot;base&quot;, &quot;recommended&quot;)),] # determine the library where the packages are installed path.lib &lt;- unique(ip$LibPath) # create a vector with all the names of the packages you want to remove pkgs.to.remove &lt;- ip[,1] head(pkgs.to.remove) # remove the packages sapply(pkgs.to.remove, remove.packages, lib = path.lib) 15.4.2 Shortcuts Was wäre das Leben ohne shortcuts. Für viele Anwendungen spart es wahnsinnig viel Zeit. Informationen koennen auf der RStudio Homepage gefunden werden oder direkt unter Tools -&gt; Keyboard shortcuts help.  Der shortcut für die shortcuts lautet Alt + shift + K "],["faqs.html", "15.5 FAQs", " 15.5 FAQs 15.5.1 Kalender erstellen  https://r-coder.com/calendar-plot-r/ Als erstes laden wir das calendR package: # Load the package library(calendR) # Display the current year calendR() # Specifiy the year you prefer calendR(year = 2020) # start with monday calendR(year = 2021, start = &quot;M&quot;) # change the language compared with the operating system Sys.setlocale(&quot;LC_ALL&quot;, &quot;English&quot;) ## [1] &quot;LC_COLLATE=English_United States.1252;LC_CTYPE=English_United States.1252;LC_MONETARY=English_United States.1252;LC_NUMERIC=C;LC_TIME=English_United States.1252&quot; calendR(year = 2021, start = &quot;M&quot;, special.days = c(9, 21,300, 365), special.col = &quot;lightblue&quot; ) # highlight all the weekends calendR(year = 2021, start = &quot;M&quot;, special.days = &quot;weekend&quot;) # Color all weekends 15.5.2 RStudio  https://community.rstudio.com/t/plots-not-showing-up-in-the-plots-pane-in-rstudio/3981/5 Falls die Plots nicht in im plots Fenster oder im Viewer der RStudio Benutzeroberfläche angezeigt werden, sondern aussschließlich unter dem code chunk, dann müssen die folgenden Einstellungen gesetzt werden: Figure 15.1: Lage Standort Speicherkoog 15.5.3 Datenmanipulation 15.5.3.1 Create decadal data Ein schneller Schritt eine Spalte pro Dekade zu erstellen geht folgendermaßen: # Example with the gapminder data gapminder %&gt;% select(year, country, pop) %&gt;% head(n = 5) ## # A tibble: 5 x 3 ## year country pop ## &lt;int&gt; &lt;fct&gt; &lt;int&gt; ## 1 1952 Afghanistan 8425333 ## 2 1957 Afghanistan 9240934 ## 3 1962 Afghanistan 10267083 ## 4 1967 Afghanistan 11537966 ## 5 1972 Afghanistan 13079460 # Use floor() and round to the nearest border gapminder %&gt;% mutate( decade = floor(year / 10), decade = decade * 10, decade = factor(decade) ) %&gt;% select(year, decade, country, pop) %&gt;% head(n = 5) ## # A tibble: 5 x 4 ## year decade country pop ## &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 1952 1950 Afghanistan 8425333 ## 2 1957 1950 Afghanistan 9240934 ## 3 1962 1960 Afghanistan 10267083 ## 4 1967 1960 Afghanistan 11537966 ## 5 1972 1970 Afghanistan 13079460 15.5.3.2 String manipulation  http://www.endmemo.com/r/gsub.php  https://bookdown.org/rdpeng/rprogdatascience/r-nuts-and-bolts.html#summary Die wichtigsten R Funktionen um Strings zu bearbeiten sind: grep() und grepl(): Sucht nach einem regulären Ausdruck in einem String regexpr(), gregexpr() und regexec(): Sucht nach Treffern in einem regulären Ausdruck und geben die Indizes wieder, wo der Treffer auftrifft. sub() und gsub(): Sucht nach einem regulären Ausdruck in einem String und ersetzt diesen Das Muster ist dabei pattern - replacement: gsub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE) x &lt;- &quot;Eine tolle Exursion&quot; gsub(&quot;Eine tolle&quot;, &quot;Die weltbeste&quot;, x) ## [1] &quot;Die weltbeste Exursion&quot; 15.5.3.3 Split a single column into multiple columns  https://cmdlinetips.com/2018/03/how-to-split-text-in-a-column-in-data-frame-in-r/ Beim Anlegen von Variablennamen kann man Informationen in dem jeweiligen Namen bereits hinterlegen. Zum Beispiel die Codierung 01_10_st kann vom Standort 01 in 10 cm Tiefe der Parameter Bodentemperatur sein. Möchte ich diese Spalteninformationen nun auf mehrer Spalten Verteilen eignet sich die Funktion separate. x &lt;- tibble( id = &quot;01_10_st&quot;, value = 10.3 ) x ## # A tibble: 1 x 2 ## id value ## &lt;chr&gt; &lt;dbl&gt; ## 1 01_10_st 10.3 # Create new columns with the information from the id column y &lt;- x %&gt;% separate(id, into = c(&quot;study_site&quot;, &quot;depth&quot;, &quot;parameter&quot;)) y ## # A tibble: 1 x 4 ## study_site depth parameter value ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 01 10 st 10.3 Aber Achtung. R ist auch hier Anfällig gegenüber Groß- Kleinschreibung. x &lt;- &quot;Eine tolle Exursion&quot; gsub(&quot;Eine Tolle&quot;, &quot;Die weltbeste&quot;, x) ## [1] &quot;Eine tolle Exursion&quot; Ich kann aber auch das Argument setzen, dass Kleinschreibung egal ist mit: x &lt;- &quot;Eine tolle Exursion&quot; gsub(&quot;Eine Tolle&quot;, &quot;Die weltbeste&quot;, x, ignore.case = T) ## [1] &quot;Die weltbeste Exursion&quot; "],["visualisation.html", "15.6 Visualisation", " 15.6 Visualisation 15.6.1 Superscripts and subscripts Um Zahlen an Plot labels hoch- oder tiefzustellen, bspw. Achsenbeschriftung oder Titel, kann man die Befehlen èxpressionundpaste` verwenden. Expression ermöglicht die Verwendung von Sonderzeichen und paste ermöglicht die Sonderzeichen mit normalem Text zu verknüpfen. # Erstelle willkürlich Daten a mit vier Gruppen in b x &lt;- tibble( a = rnorm(n = 100, mean = 50, sd = 2), b = rep(x = c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;), 25) ) x %&gt;% ggplot(aes(a, b, group = b)) + geom_boxplot() # [] Tiefstellen x %&gt;% ggplot(aes(a, b, group = b)) + geom_boxplot() + labs( title = &quot;Eine tolle Überschrift&quot;, x = &quot;Einheit (XY)&quot;, y = expression(E[H]) ) # ^ Hochstellen x %&gt;% ggplot(aes(a, b, group = b)) + geom_boxplot() + labs( title = &quot;Eine tolle Überschrift&quot;, x = &quot;Einheit (XY)&quot;, y = expression(m^2) ) # Kombination + normaler Text x %&gt;% ggplot(aes(a, b, group = b)) + geom_boxplot() + labs( title = &quot;Eine tolle Überschrift&quot;, x = &quot;Einheit (XY)&quot;, y = expression(paste(&quot;Ca&quot; ^&quot;2+&quot;, &quot; Verteilung (g &quot;, cm^-3, &quot;)&quot;)) ) # Bei langen Beschriftungen eignen sich auch Zeilenumbrüche, die mit &quot;\\n&quot; erzeugt werden x %&gt;% ggplot(aes(a, b, group = b)) + geom_boxplot() + labs( title = &quot;Eine tolle \\nÜberschrift&quot;, x = &quot;Einheit (XY)&quot;, y = expression(paste(&quot;Ca&quot; ^&quot;2+&quot;, &quot; Verteilung (g &quot;, cm^-3, &quot;)&quot;)) ) 15.6.2 Modifying labels in faceted plots  https://biostats.w.uib.no/modifying-labels-in-faceted-plots/ Figure 15.2: @Henry Wang taken from: https://henrywang.nl/ggplot2-theme-elements-demonstration/ # Darstellung des gesamten Zeitraums koog_day %&gt;% filter(year &gt; &quot;2010&quot; &amp; year &lt; &quot;2013&quot;) %&gt;% ggplot(aes(daily, st10)) + geom_line() # Darstellen pro Jahr p &lt;- koog_day %&gt;% filter(year &gt; &quot;2010&quot; &amp; year &lt; &quot;2013&quot;) %&gt;% ggplot(aes(daily, st10)) + geom_line() + facet_wrap(~year, scales = &quot;free_x&quot;) p Ändern der Hintegrundfarbe p + theme(strip.background = element_rect(fill=&quot;lightblue&quot;, size=1, color=&quot;darkblue&quot;)) Ändern der Schriftfarbe p + theme(strip.text.x = element_text(size=12, face=&quot;italic&quot;, color=&quot;darkblue&quot;)) Ändern der Beschriftung ist nicht ganz unkompliziert, da die Beschriftung von den Variablennamen der Spalten genommen wird. Möglichkeit 1 wäre, die Beschriftung im Datensatz direkt zu ändern. Möglichkeit zwei ist einen neuen Namensvektor zu erstellen und die Funktion labeller = labeller() zu verwenden. # Erstelle Namensvektor new_name &lt;- c(&quot;2011&quot; = &quot;Gute Zeiten&quot;, &quot;2012&quot; = &quot;Schlechte Zeiten&quot;) # Nutze die Funktion labeller koog_day %&gt;% filter(year &gt; &quot;2010&quot; &amp; year &lt; &quot;2013&quot;) %&gt;% ggplot(aes(daily, st10)) + geom_line() + facet_wrap(~year, scales = &quot;free_x&quot;, labeller = labeller(year = new_name)) Auch der Abstand zwischen den Panels kann verändert werden mit theme(panel.spacing = unit()). # Hm....es gibt immer noch einen overlap bei der X-Achse p + theme(panel.spacing.x = unit(.25, &quot;cm&quot;)) # JA :) Besser p + theme(panel.spacing.x = unit(1.25, &quot;cm&quot;)) "],["glossary.html", "15.7 Glossary", " 15.7 Glossary Shell In der Informatik wird als Shell die Software bezeichnet, mittels derer ein Benutzer mit einem Betriebssystem interagiert  eine Mensch-Maschine-Schnittstelle. Während Kernel den Kern eines Betriebssystems bezeichnet, ist die Shell (englisch für Schale, Hülle oder Außenhaut) anschaulich dessen Außenschicht und damit Schnittstelle (englisch Interface) zum Benutzer. Synonym = terminal, command line, and console GUI Grafische Benutzeroberfläche oder auch grafische Benutzerschnittstelle oder Bedienoberfläche (Abk. GUI von englisch graphical user interface) bezeichnet eine Form von Benutzerschnittstelle eines Computers. Sie hat die Aufgabe, Anwendungssoftware auf einem Rechner mittels grafischer Symbole, Steuerelemente oder auch Widgets genannt, bedienbar zu machen. Clipboard Ein Clipboard ist der englischsprachige Begriff für eine Zwischenablage in der elektronischen Datenverarbeitung, d. h. ein virtueller Zwischenspeicher "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
=======
[["grundlagen.html", "Chapter 3 Grundlagen", " Chapter 3 Grundlagen Der Beitrag wurde das letzte mal am 26 Juli, 2021 editiert Im folgenden lernen wir mehr zu Datentypen in R und welche Rolle sie spielen. Ganz grundlegend lassen sich verschiedene Strukturen unterscheiden Zusammenfassung: Figure 3.1: Grundlegende Datenstruktur Quantitative Variablen sind nummerisch und können gemessen werden Diskret zählbar mit einer finiten Anzahl an Möglichkeiten Anzahl Kinder einer Familie Studenten in einem Klassenzimmer Brötchen in einer Tüte Kontinuierlich nicht-zählbar mit einer infiniten Anzahl an Möglichkeiten Alter (e.g. ein 28-jähriger Mann kann spezifischer ausgedrückt 28 Jahre, 7 Monate, 16 Tage, 3 Stunden, 4 Minuten, 5 Sekunden, 31 Milisekunden,  alt sein. Alle Messungen stoppen per Konvention bei einem gewissen Level an Präzision, was uns aber nicht stoppen muss höherauflösend zu messen. Dies bedingt das unser Messwert eine infinite Anzahl an Möglichkeiten aufweisen kann. Gewicht Größe Qualitative Variable oder kategorische Variable (factor in R) sind nicht-numerisch und die Werte passen in eine Kategorie Nominal keine Hierarchie oder Ordnung in den Werten (e.g. Geschlecht (männlich/weiblich) hat keine interne Struktur Ordinal hat eine interne Ordnung (e.g. Gesundheitsstatus differenziert nach schlecht/mäßig/gut/hervorragend) Figure 3.2: Illustration von @allison_horst: https://twitter.com/allison_horst Figure 3.3: Illustration von @allison_horst: https://twitter.com/allison_horst "],["datentypen.html", "3.1 Datentypen", " 3.1 Datentypen Im folgenden werden die vier grundlegenden Datentypen (atomic vectors) behandelt: logical (TRUE, FALSE) integer (c(1, 2.4, 4.678)) double (auch als numeric bezeichnet; c(1L, 2L, 3L)) character (c(these are, some strings)) Figure 3.4: Atomic vectors, source: https://adv-r.hadley.nz/vectors-chap.html Diese Datentypen können in Form bestimmter Datenstrukturen miteinander verknüft werden. In R ist dies über die Dimensionalität der Daten definiert mit den fünf häufigsten Strukturen: Datenstrukturen in R Homogen Heterogen 1d Atomic vector List 2d Matrix Data frame nd Array  Advanced R by Hadly Wickham 3.1.1 Numerische Objekte Zahlenwerte in R werden als numeric bezeichnet mit der Unterteilung in integer (ganze Zahlen) oder double (Dezimalzahlen). Die Zuweisung von R, selbst wenn ich eine ganze Zahl zuweise, ist jedoch vom Typ double. a &lt;- 4 typeof(a) ## [1] &quot;double&quot;  Mit der Funktion typeof() kann der Objekttyp erfragt werden. Um eine ganze Zahl wiederzugeben muss ein L hinter die Zahl gesetzt werden. a &lt;- 4L typeof(a) ## [1] &quot;integer&quot; 3.1.2 Textobjekte Ein character Objekt sind Namen wie \"Kristof\", \"Tim\", \"Beste Norddeutschland Exkursion der Welt\" (Textvariablen werden auch als string bezeichnet). Um ein character Objekt zu definieren sind die Anführungsstriche als einfache ' ' oder doppelte \" \" Anführungszeichen wichtig! # Dies sind alles character Objekte &quot;Kristof&quot; ## [1] &quot;Kristof&quot; &quot;Tim&quot; ## [1] &quot;Tim&quot; &quot;Beste Norddeutschland Exkursion der Welt&quot; ## [1] &quot;Beste Norddeutschland Exkursion der Welt&quot; Bestimmte Funktionen brauchen einen numerical input, wohingegen andere einen character input benötigen. Schaue was passiert: mean(c(&quot;5&quot;, &quot;1&quot;)) Warnmeldung:In mean.default(c(5, 1)) :Argument ist weder numerisch noch boolesch: gebe NA zurück Lasse ich die Anführungsstriche weg, dann ist wieder alles im Lot: mean(c(5, 1)) ## [1] 3 3.1.3 Logicals Der dritte wichtige Objekttyp in R lautet logical und dieser kann zwei Werte annehmen: TRUE (wahr) und FALSE (falsch). Logicals entstehen durch den logischen Vergleich zwischen zwei Werten oder den Elementen eines Vektors. Operatoren die für diese Anfrage genutzt werden können lauten: Logische Operatoren in R. Operator Bedeutung Beispiel == ist gleich 1==1 (ergibt TRUE) a==b (ergibt FALSE) != ist nicht gleich 1 != 1 (ergibt FALSE) a != b (ergibt TRUE) &lt; ist kleiner als 1 &lt; 2 (ergibt TRUE) 2 &lt; 2 (ergibt FALSE) &gt; ist größer als 2 &gt; 1 (ergibt TRUE) 2 &gt; 2 (ergibt FALSE) &lt;= ist kleiner gleich 1 &lt;= 2 (ergibt TRUE) 2 &lt;= 2 (ergibt TRUE) &gt;= ist größer gleich 2 &gt;= 1 (ergibt TRUE) 2 &gt;= 2 (ergibt TRUE) 3.1.4 Fehlende Werte In R werden fehlende Werte mit NA für not available gekennzeichnet. Für bestimmte Funktionen und Anwendungen ist es wichtig, falls ein NA Wert in einer Zeitreihe auftritt ( leider ist dies in langen Zeitreihen fast immer der Fall), R explizit zu sagen was mit diesen Werten getan werden soll. # Ich habe einen Vektor mit einem fehlenden Wert NA a &lt;- c(1,2,3,4,NA,5) mean(a) ## [1] NA Hmder Mittelwert von 1,2,3,4,NA und 5 ist NA und nicht eine Zahl? Wie kommt das bloß. In dem Fall ist es nützlich in die Dokumentation der Funktion mean() nachzuschauen. ?mean Default S3 method: mean(x, trim = 0, na.rm = FALSE, ) Die default Argumente der Funktion lauten na.rm = FALSE, was soviel bedeutet na Werte nicht zu entfernen sondern in die Berechnung mit einzubeziehen.  na steht für fehlende Werte (NA) und rm ist die Kurzform für remove, also entfernen. Damit unsere Rechnung funktioniert müssen wir in der mean() Funktion das Argument na.rm = TRUE setzen, also erst die fehlende Werte entfernen und dann den Mittelwert berechnen: mean(a, na.rm = TRUE) ## [1] 3  Es funktioniert! Dies ist tatsächlich einer der häufigsten Fehler und egal wie häufig man daran denkt, es kommt immer wieder vor das dies einer der Gründe ist warum man sich Stunden den Kopf über ein nicht funktionierendes Skript zerbricht  3.1.5 Weitere Objekttypen Neben den drei vermeintlich wichtigsten Objekttypen (numeric, character, logical) gibt es in R noch die Typen für Kategoriale Variablen factor Datumsangaben date Datumsangaben + Zeit datetime  und weitere Wenn man Daten in R einliest muss man R jedoch einen Schubser geben, damit eine Spalte bspw. auch als dateerkannt wird und nicht als character oder numeric. Wie man dies berücksichtigt lernen wir in dem Kapitel Daten einlesen. 3.1.5.1 S3 Objekte Vektoren in R weisen verschiedene Attribute auf. Die zwei wichtigsten Attribute sind: dimension (wandelt einen Vektor in eine Matrix oder Liste um) class (bedient S3 Objekte, bspw. factor, date und POSIXct) Wenn ein Objekt in R ein class Attribut besitzt wird es automatisch in ein S3 object umgewandelt und unterscheidet sich dadurch von einem normalen Vektor. Figure 3.5: S3 atomic vectors, source: https://adv-r.hadley.nz/vectors-chap.html#s3-atomic-vectors factor sind bspw. aufgebaut aus den Attributen class und levels um kategorische Daten zu speichern. 3.1.6 Objekttypen ändern Die Syntax in R um Objekte umzuwandeln lautet as.[Objekttyp]. a &lt;- &quot;25&quot; typeof(a) ## [1] &quot;character&quot; a &lt;- as.numeric(a) typeof(a) ## [1] &quot;double&quot; Dies klappt allerdings nur, insofern die Umwandlung logisch ist. In allen anderen Fällen gibt es eine Warnmeldung unter Erzeugung von NAs anstelle der Werte. a &lt;- as.numeric(&quot;Beste Norddeutschland Exkursion der Welt&quot;) ## Warning: NAs introduced by coercion "],["datenstrukturen.html", "3.2 Datenstrukturen", " 3.2 Datenstrukturen Figure 3.6: Vergleich eines Skalars und eines Vektors Der einfachste Datentyp in R ist ein Skalar (Mathematische Größe, die allein durch die Angabe eines Zahlenwertes charakterisiert ist). Im Gegensatz zu der mathematischen Beschreibung, kann in R ein Skalar jedoch character sein und muss nicht zwangsläufig als numeric definiert sein. Mathematische Operationen sind mit numerischen Skalaren möglich, nicht jedoch wenn diese in R als character gespeichert sind. a &lt;- &quot;1&quot; b &lt;- &quot;2&quot; a + b Fehler in a + b : nicht-numerisches Argument für binären Operator Bisher haben wir einfache Objekte in R erzeugt, wie eben genau Skalare oder kürzere Vektoren. Es gibt jedoch noch weitere Datenstrukturen, die sich hinsichtlich der Dimensionalität unterscheiden (1D und 2D) und ob die Objekttypen homogen (nur ein Objekttyp) und heterogen (unterschiedliche Objekttypen) beinhalten: |Datenstruktur | Dimensionalität | Objekttypen| |Vektor | eindimensional | homogen| |Liste | eindimensional |heterogen| |Matrix | zweidimensional | homogen| |Dataframe | zweidimensional |heterogen| Table: Datenstrukturen in R. 3.2.1 Vektor Ein Vektor ist eine Ansammlung von Skalaren, die als ein R Objekt gespeichert wurden. Die Zahlen von 1 bis 10 bspw. bilden einen numerischen Vektor mit der Länge 10. Die Buchstaben im Alphabet sind ein Vektor mit der Länge 26.  Vektoren können nur numeric oder character seinnicht beides! Es gibt verschiedene Möglichkeiten einen Vektor selber zu bilden. Funktionen um einen Vektor zu erzeugen. Funktion Beispiel Ergebnis c(a, b, ...) c(1, 5, 9) 1, 5, 9 a:b 1:5 1, 2, 3, 4, 5 seq(from, to, by, length.out) seq(from = 0, to = 6, by = 2) 0, 2, 4, 6 rep(x, times, each, length.out) rep(c(7, 8), times = 2, each = 2) 7, 7, 8, 8, 7, 7, 8, 8 Die einfachste Möglichkeit einen Vektor zu erzeugen ist mit der c() Funktion. c leitet sich von dem englischen Wort concatenate ab und lässt sich frei übersetzen mit zusammenbringen oder zusammenführen. # Speichere einen Vektor mit den Zahlen von 1 bis 10 a &lt;- c(1,2,3,4,5,6,7,8,9,10) # Stelle die Zahlen dar a ## [1] 1 2 3 4 5 6 7 8 9 10 Man kann auch Vektoren miteinander verknüpfen: a &lt;- c(1,2,3,4,5) b &lt;- c(6,7,8,9,10) x &lt;- c(a, b) x ## [1] 1 2 3 4 5 6 7 8 9 10  Yeah! Das hat ja gut geklappt. Man kann auch character Vektoren erstellen mit demselben Prinzip wort_vec &lt;- c(&quot;Beste&quot;, &quot;Exkursion&quot;, &quot;der&quot;, &quot;Welt&quot;) wort_vec ## [1] &quot;Beste&quot; &quot;Exkursion&quot; &quot;der&quot; &quot;Welt&quot; Wenn ihr allerdings einen Vektor von 1:1000 erstellen wollt  Aber keine Sorge! Auch hierfür gibt es Funktionen in R um das Leben zu erleichtern. 3.2.1.1 a:b Die Vektoren werden in Inkrementen von 1 aufgefüllt 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 # Das ganze geht auch Rückwärts 10:1 ## [1] 10 9 8 7 6 5 4 3 2 1 # Oder mit nicht runden Zahlen (non-integers) 2.5:8.5 ## [1] 2.5 3.5 4.5 5.5 6.5 7.5 8.5 3.2.1.2 seq() Diese Funktion musste ich für Zeitreihenuntersuchungen schon öfter verwenden und ist ein wahrer Retter in der Not. Argument Definition from Beginn der Sequenz to Ende der Sequenz by Die Inkremente length.out Die gewünschte Länge der Sequent (nur wichtig wenn by festgelegt wurde) # Erstelle Nummer von 1 bis 10 in einer Schritten seq(from = 1, to = 10, by = 1) ## [1] 1 2 3 4 5 6 7 8 9 10 # Erstelle ganze Zahlen von 0 bis 100 in 10er Schritten seq(from = 0, to = 100, by = 10) ## [1] 0 10 20 30 40 50 60 70 80 90 100 Wenn das Argument length.out verwendet wird, entspricht die Länge des Vektors dem Wert von length.out. # Erstelle 10 Zahlen von 1 bis 5 seq(from = 1, to = 5, length.out = 10) ## [1] 1.000000 1.444444 1.888889 2.333333 2.777778 3.222222 3.666667 4.111111 ## [9] 4.555556 5.000000 # Erstelle 3 Zahlen von 0 bis 100 seq(from = 0, to = 100, length.out = 3) ## [1] 0 50 100 3.2.1.3 rep() Argument Definition x Ein Skalar oder Vektor der wiederholt werden soll times Die Anzahl wie häufig x wiederholt werden soll each Die Anzahl wie häufig jeder Wert in x wiederholt werden soll length.out Die gewünschte Länge der Sequenz Die rep() Funktion erlaubt es also einen Skalar oder Vektor beliebig oft zu wiederholen. rep(x = 3, times = 10) ## [1] 3 3 3 3 3 3 3 3 3 3 rep(x = c(1, 2), each = 3) ## [1] 1 1 1 2 2 2 rep(x = 1:3, length.out = 10) ## [1] 1 2 3 1 2 3 1 2 3 1  Man kann eine a:b Funktion mit einer rep() Funktion verknüpfen.  Sogar das times und each Argument lassen sich in die rep() Funktion integrieren rep(x = 1:3, each = 2, times = 2) ## [1] 1 1 2 2 3 3 1 1 2 2 3 3 3.2.1.4 Vektorelemente auswählen Um auf eine Zahl in einem Vektor zuzugreifen können wir dies über eine eckige Klammer [] tun. a &lt;- c(1,2,3,4,5) a[2] ## [1] 2 a[5] ## [1] 5 Wenn wir mehrere Elemente des Vektors auswählen möchten, dann müssen wir einen neuen Vektor über die Positionen erzeugen, beispielsweise um das erste, dritte und fünfte Element des Vektors auszugeben: a[c(1,3,5)] ## [1] 1 3 5 Eine weitere Möglichkeite die ersten drei Elemente eines Vektors auszuwählen ist mit dem Doppelpunkt : was so viel bedeutet wie von bis. a[1:4] ## [1] 1 2 3 4 Elemente in einem Vektor können auch mit = benannt werden. Bei der Benennung von Spaltennamen in einer Tabelle (dataframe oder Matrix in R) ist der Befehl ähnlich. namen &lt;- c(eins = &quot;Dies&quot;, zwei = &quot;ist&quot;, drei = &quot;ein&quot;, vier = &quot;Test&quot;) namen ## eins zwei drei vier ## &quot;Dies&quot; &quot;ist&quot; &quot;ein&quot; &quot;Test&quot; namen[&quot;vier&quot;] ## vier ## &quot;Test&quot; 3.2.2 Liste Listen ähneln Vektoren und können über die Funktion list() erzeugt werden. Beispielsweise der Standort Speicherkoog kann als Liste wie folgt erzeugt werden: koog &lt;- list(country = &quot;Germany&quot;, state = &quot;Schleswig-Holstein&quot;, city = &quot;Meldorf&quot;, name = &quot;Speicherkoog&quot;) koog ## $country ## [1] &quot;Germany&quot; ## ## $state ## [1] &quot;Schleswig-Holstein&quot; ## ## $city ## [1] &quot;Meldorf&quot; ## ## $name ## [1] &quot;Speicherkoog&quot; Die Darstellung gegenüber Vektoren ist jedoch eine andere. Anstelle der Darstellung nebeneinander werden die Listen Elemente untereinander dargestellt. 3.2.3 Matrix und dataframe Figure 3.7: Darstellung von Datenstrukturen 3.2.3.1 Matrix Eine Matrix ist eine zweidimensionale Struktur und kann mit der Funktion matrix() erzeugt werden. # Erstelle einen Vektor von 1 bis 10 a &lt;- c(1:10) # Teile den Vektor auf zwei Spalten auf b &lt;- matrix(a, ncol = 2) b ## [,1] [,2] ## [1,] 1 6 ## [2,] 2 7 ## [3,] 3 8 ## [4,] 4 9 ## [5,] 5 10 # Teile den Vektor auf zwei Zeilen auf c &lt;- matrix(a, nrow = 2) c ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 Mit der Funktion rbind() (row = Zeile) oder cbind() (column = Spalte) können wir mehrere Vektoren auch zusammenführen. a &lt;- c(1:10) b &lt;- c(11:20) c &lt;- c(21:30) # Erstelle eine Matrix mit drei Spalten cbind(a,b,c) ## a b c ## [1,] 1 11 21 ## [2,] 2 12 22 ## [3,] 3 13 23 ## [4,] 4 14 24 ## [5,] 5 15 25 ## [6,] 6 16 26 ## [7,] 7 17 27 ## [8,] 8 18 28 ## [9,] 9 19 29 ## [10,] 10 20 30 # Erstelle eine Matrix mit drei Zeilen rbind(a,b,c) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## a 1 2 3 4 5 6 7 8 9 10 ## b 11 12 13 14 15 16 17 18 19 20 ## c 21 22 23 24 25 26 27 28 29 30 Die Spalten- oder Zeilennamen einer Matrix können auch benannt oder umbenannt werden mit der Funktion colnames() oder rownames(). mat &lt;- rbind(a,b,c) mat ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## a 1 2 3 4 5 6 7 8 9 10 ## b 11 12 13 14 15 16 17 18 19 20 ## c 21 22 23 24 25 26 27 28 29 30 rownames(mat) &lt;- c(&quot;Zeile 1&quot;, &quot;Zeile 2&quot;, &quot;Zeile 3&quot;) mat ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## Zeile 1 1 2 3 4 5 6 7 8 9 10 ## Zeile 2 11 12 13 14 15 16 17 18 19 20 ## Zeile 3 21 22 23 24 25 26 27 28 29 30 Eine nützliche Funktion lautet t() um eine Matrix oder dataframe zu transponieren, also umzuwandeln und um 90° zu vertauschen. # Transponiere die Matrix mat t(mat) ## Zeile 1 Zeile 2 Zeile 3 ## [1,] 1 11 21 ## [2,] 2 12 22 ## [3,] 3 13 23 ## [4,] 4 14 24 ## [5,] 5 15 25 ## [6,] 6 16 26 ## [7,] 7 17 27 ## [8,] 8 18 28 ## [9,] 9 19 29 ## [10,] 10 20 30 Unsere Zeilennamen machen jetzt natürlich keinen Sinn mehr  Versuche mal die Spaltennamen richtig zu beschriften. 3.2.3.2 Dataframe Eine Matrix ähnelt der Datenstruktur wie man sie aus Excel, SPSS etc. kennt. Großer Unterschied ist aber, dass eine Matrix nur einen Datentyp erlaubt und ein dataframe mehrere Typen. Mit der Funktion data.frame() können wir gleich lange Vektoren unterschiedlichen Typs kombinieren. # Erstelle einen dataframe beatles_data &lt;- data.frame( name = c(&quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, &quot;Ringo&quot;), surname = c(&quot;Lennon&quot;, &quot;McCartney&quot;, &quot;Harrison&quot;, &quot;Starr&quot;), born = c(1940, 1942, 1943, 1940) ) beatles_data ## name surname born ## 1 John Lennon 1940 ## 2 Paul McCartney 1942 ## 3 George Harrison 1943 ## 4 Ringo Starr 1940 Die händische Eingabe von tabellarischen Daten wäre natürlich umständlich. In R gibt es einfache Möglichkeiten diese aus externen Datenquellen (z.B. CSV, Excel, txt, ) einzulesen und zu verarbeiten. 3.2.3.3 tibble tibble haben dieselbe Datenstruktur wie data.frame, nur das Attribut class in einem tibble ist länger: # create a data frame df1 &lt;- data.frame( x = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), y = c(1,2,3) ) typeof(df1) ## [1] &quot;list&quot; attributes(df1) ## $names ## [1] &quot;x&quot; &quot;y&quot; ## ## $class ## [1] &quot;data.frame&quot; ## ## $row.names ## [1] 1 2 3 # create a tibble df2 &lt;- tibble( x = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), y = c(1,2,3) ) typeof(df2) ## [1] &quot;list&quot; attributes(df2) ## $names ## [1] &quot;x&quot; &quot;y&quot; ## ## $row.names ## [1] 1 2 3 ## ## $class ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; "],["zufallszahlen-erzeugen.html", "3.3 Zufallszahlen erzeugen", " 3.3 Zufallszahlen erzeugen R ist eine Statistiksprache und da wäre es doch verwunderlich wenn es nicht auch Funktionen gibt, um Zufallszahlen zu erzeugen. Für Vektoren ist dies die Funktion sample(): Argument Definition x Ein Vektor (character oder numeric) von dem die Zufallszahlen erzeugt werden. size Die Anzahl der Zufallszahlen. Der Standard (default) ist die Länge des Vektors x. replace Standard ist FALSE. Bei TRUE kann die Zahl mehrmals vorkommen. prob Ein Vektor der Möglichkeiten für x mit der Wahrs x is. The vector of probabilities you give as an argument should add up to one. If you dont specify the prob argument, all outcomes will be equally likely. # Die Zahlen 1 bis 5 treten nur einmal auf sample(x = 1:5, size = 5) ## [1] 3 1 2 5 4 # Die Zahlen 1 bis 5 können ggf. mehrmals auftreten hei replace = TRUE sample(x = 1:5, size = 5, replace = T) ## [1] 5 2 5 1 4 Figure 3.8: Illustration von @allison_horst: https://twitter.com/allison_horst Die erzeugten Zufallsvariablen können dabei normalverteilt oder nicht-normalverteilt sein. Es gibt jedoch noch eine Vielzahl weiterer Funktionen in R, die mit dem help Befehl aufgerufen werden können ?Distributions Die normale Standardverteilung (auch bekannt unter Gausssche Normalverteilung) kann mit der Funktion rnorm erzeugt werden. Es können dabei die folgenden Argumente gesetzt werden. Argument Definition n Stichprobenanzahl. mean Mittelwert der Verteilung. sd Standardabweichung der Verteilung. # Erstelle 100000 Zahlen mit dem Mittelwert 10 und der Standardverteilung 3 a &lt;- rnorm(n = 100000, mean = 10, sd = 3) a &lt;- as.data.frame(a) # Erstelle zwei weitere Spalten. Selber Mittelwert aber unterschiedliche SD # Keine Sorge! Was das komische Symbol %&gt;% bedeutet lernen wir später colnames(a) &lt;- c(&quot;norm_3&quot;) a &lt;- a %&gt;% mutate(norm_1 = rnorm(n = 100000, mean = 10, sd = 1)) %&gt;% mutate(norm_0.5 = rnorm(n = 100000, mean = 10, sd = 0.5)) %&gt;% pivot_longer(cols = everything()) # Erstelle die Abbildung mit ggplot...keine Sorge. Die Power von ggplot lernt ihr später kennen. a %&gt;% ggplot(aes(x = value, color = fct_reorder(.f = name, .x = value, .fun = max))) + geom_density(alpha = 0.1) + scale_color_discrete(name = &quot;Standardabweichung&quot;) + my_theme Das Erzeugen der Daten ist spielend leicht. Plotten der Daten vermittelt weiterhin einen Eindruck davon, wie die Dichteverteilung der Daten variiert bei gleichem mean() aber unterschiedlicher sd(). Was sagt euch die Stichprobenanzahl über das Aussehen der Kurve aus? # Normalverteilung bei 10 Zufallszahlen a &lt;- rnorm(n = 10, mean = 10, sd = 3) %&gt;% as.data.frame() p1 &lt;- a %&gt;% ggplot(aes(x = .)) + geom_density(alpha = 0.1) + labs( title = &quot;n = 10&quot; ) + geom_vline(aes(xintercept = mean(.)), color = &quot;red&quot;) + my_theme # Normalverteilung bei 100 Zufallszahlen a &lt;- rnorm(n = 100, mean = 10, sd = 3) %&gt;% as.data.frame() p2 &lt;- a %&gt;% ggplot(aes(x = .)) + geom_density(alpha = 0.1) + labs( title = &quot;n = 100&quot; ) + geom_vline(aes(xintercept = mean(.)), color = &quot;red&quot;) + my_theme # Normalverteilung bei 100.000 Zufallszahlen a &lt;- rnorm(n = 100000, mean = 10, sd = 3) %&gt;% as.data.frame() p3 &lt;- a %&gt;% ggplot(aes(x = .)) + geom_density(alpha = 0.1) + labs( title = &quot;n = 100.000&quot; ) + geom_vline(aes(xintercept = mean(.)), color = &quot;red&quot;) + my_theme p1 + p2 + p3  Jedes mal wenn das Skript neu ausgeführt wird, ändern sich auch die Zufallszahlen. "],["rechnen-mit-vektoren.html", "3.4 Rechnen mit Vektoren", " 3.4 Rechnen mit Vektoren Es lassen sich mit Vektoren mathematische Operationen und zusammenfassende Statistiken durchführen. Im folgenden wollen wir Redoxpotenziale umrechnen, welche mit einer Silber-Silberchlorid Elektrode gemessen wurden. Für die Vergleichbarkeit und korrekte Nomenklatur sollten die Werte jedoch immer gegen die Standardwasserstoffelektrode (SHE) angegeben werden. Das Potenzial der SHE ist bei 25 °C um +207 mV größer, als das der Ag-AgCl Elektrode. Was müssen wir also tun? Wir müssen auf jeden Wert +207 mV addieren. Kein Problem in R: # Ein Vektor mit gemessenen Redoxpotenzialen einer Ag-AgCl Elektrode # Die Funktion `runif()` erzeugt Werte mit einer stetigen Gleichverteilung zwischen min() und max() e_agcl &lt;- runif(n = 100, min = 400, max = 500) # Addition von +207 mV auf jeden Wert des Vektors eh &lt;- e_agcl + 207 # Erstelle einen data frame aus den beiden Vektoren df &lt;- data.frame(e_agcl, eh) df &lt;- df %&gt;% mutate(n = seq(from = 1, to = nrow(df))) %&gt;% pivot_longer(cols = c(&quot;e_agcl&quot;, &quot;eh&quot;)) # Plotte die Darstellung df %&gt;% ggplot(aes(n, value, color = name)) + geom_line() + labs( title = &quot;Verlauf der Redoxpotenziale (korrigiert und unkorrigiert)&quot;, x = &quot;Zeit&quot;, y = expression(paste(&quot;E&quot;[H], &quot; (mV)&quot;)) ) + coord_cartesian(ylim = c(0, 800)) + my_theme Wenn wir mathematische Berechnungen mit einem Skalar an einem Vektor durchführen (in unserem Fall +207 mV), dann führt R die Berechnung für jedes Element des Vektors durch. Es ist nicht nur Addition möglich, sondern auch Subtraktion, Multiplikation und Division. Selbst logarithmieren und entlogarithmieren etc. ist kein Problem. Eine Zusammfassung der möglichen Operationen seht ihr unten: Statistik Funktionen in R. Funktion Beispiel Ergebnis sum(x), product(x) sum(1:10) 55 min(x), max(x) min(1:10) 1 mean(x), median(x) mean(1:10) 5.5 sd(x), var(x), range(x) sd(1:10) 3.0276504 quantile(x, probs) quantile(1:10, probs = .2) 2.8 summary(x) summary(1:10) Min = 1.00. 1st Qu. = 3.25, Median = 5.50, Mean = 5.50, 3rd Qu. = 7.75, Max = 10.0 Lasst uns den Mittelwert und die Standardabweichung des Redoxpotentziales der Zeitreihe berechnen (wenn nicht explizit erwähnt beziehe ich mich immer auf den EH Wert in mV gemessen). # Mittelwert mean(eh) ## [1] 656.6756 # SD sd(eh) ## [1] 28.71994 Kein Problem mehr für uns  Vektoren sind simple 1-dimensionale Objekte in R. Wir haben jedoch auch schon Objekte wie Matrix, dataframe oder Listen kennengelernt. Eine grundlegende Sache einer Matrix oder eines dataframe ist es, dass die Vektoren diesselbe Länge haben müssen! Dies lässt sich mit der Funktion length() überprüfen. Wie lang war nochmal unser eh Vektor? length(eh) ## [1] 100 Die length() Funktion ist nicht die einzige wichtige Funktion um mit Vektoren oder Daten im Allgemeinen zu arbeiten. Für eure Arbeit mit R sind folgende wichtig: Funktion Beschreibung Beispiel Ergebnis round(x, digits) Runde Elemente in x zu digits Stellen round(c(2.231, 3.1415), digits = 1) 2.2, 3.1 ceiling(x), floor(x) Runde Elemente in x Auf (oder ab) zur nächsten ganzen Zahl ceiling(c(5.1, 7.9)) 6, 8 x %% y Ganzzahlige Division (ie. x durch y) 7 %% 3 1 "],["str-funktion.html", "3.5 str() Funktion", " 3.5 str() Funktion Eine wichtige Funktion um Informationen über einen Datensatz oder ein Objekt zu bekommen ist die Funktion str(), kurz für structure. Diese Funktion lässt sich auf alle Datenstrukturen in R anweden, also für Vektoren, Listen, Matrix und dataframes. # Erkunden eines Vektors mit 100 Zufallszahlen str(eh) ## num [1:100] 650 643 680 630 685 ... Hier kann man folgende Informationen draus ablesen: Es handelt sich um ein numeric Datenformat Der Vektor hat 100 Elemente von 1 bis 100 Die ersten fünf Zahlen lauten  Haben wir ein komplizierteres Objekt wie den mtcars Datensatz wird die str() Auflistung etwas komplexer: # Erkunden des Datensatzes mtcars str(mtcars) ## &#39;data.frame&#39;: 32 obs. of 11 variables: ## $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... ## $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... ## $ disp: num 160 160 108 258 360 ... ## $ hp : num 110 110 93 110 175 105 245 62 95 123 ... ## $ drat: num 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... ## $ wt : num 2.62 2.88 2.32 3.21 3.44 ... ## $ qsec: num 16.5 17 18.6 19.4 17 ... ## $ vs : num 0 0 1 1 0 1 0 1 1 1 ... ## $ am : num 1 1 1 0 0 0 0 0 0 0 ... ## $ gear: num 4 4 4 3 3 3 3 4 4 4 ... ## $ carb: num 4 4 1 1 2 1 4 2 2 4 ... Wir können an der Datenstruktur erkennen, dass es sich um einen data.frame handelt mit 32 observations von 11 Variablen. Alle haben den Datentyp numeric. Die Liste ist jedoch so lang, dass sie nicht komplett dargestellt wird. Wollen wir nur die ersten fünf Einträge anzeigen geht dies mit der head() Funktion und die letzten fünf Einträge mit der tail() Funktion: head(mtcars, n = 5) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 tail(mtcars, n = 5) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.5 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.5 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.6 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.6 1 1 4 2 Wenn man den Namen des Datensatzes / Objektes in die Funktion View() - V dabei groß geschrieben - eingibt, dann kann man sich den Datensatz auch im Viewer Fenster von R ansehen. View(mtcars) "],["selektion-von-spaltenzeilen-in-dataframes.html", "3.6 Selektion von Spalten/Zeilen in dataframes", " 3.6 Selektion von Spalten/Zeilen in dataframes Man kann auf einen einzelnen Vektor des mtcars dataframes zugreifen, indem man den Namen des Datensatzes mit dem $ und weiterhin mit dem Spaltennamen verknüpft: # Zeige mit die Pferdestärken (hp) der Fahrzeuge an mtcars$hp ## [1] 110 110 93 110 175 105 245 62 95 123 123 180 180 180 205 215 230 66 52 ## [20] 65 97 150 150 245 175 66 91 113 264 175 335 109 Das Ergebnis ist ein Vektor, mit dem wir die bekannten Vektorfunktionen anwenden können. Die eckige Zahl zu Beginn der Zeile steht dabei für das ite Element des Vektors. Die Zahl 110 steht also auf der Position (dem Index) [1] und die Zahl 245 and Position [24]. Die Darstellung erleichert es einen Überblick über die Anzahl an Elementen zu bekommen. mean(mtcars$hp) ## [1] 146.6875 Die Autos haben im Mittel also 146 PS, bereits 1974  Auch mit [] kann auf Vektoren in einem dataframe zugegriffen werden. Der Spaltenname muss hierbei jedoch in \"\" gesetzt werden. head(mtcars[&quot;hp&quot;], 5) ## hp ## Mazda RX4 110 ## Mazda RX4 Wag 110 ## Datsun 710 93 ## Hornet 4 Drive 110 ## Hornet Sportabout 175 Wenn wir die Position der Spalte hp kennen genügt aber auch die Zahl head(mtcars[4], 5) ## hp ## Mazda RX4 110 ## Mazda RX4 Wag 110 ## Datsun 710 93 ## Hornet 4 Drive 110 ## Hornet Sportabout 175 Last but not least, eine letzte Möglichkeit Daten zu spezifizieren ist durch das Setzen eines Kommas: # Wähle die ersten zwei Zeilen aus aber ALLE Spalten head(mtcars[1:2, ], 5) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21 6 160 110 3.9 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21 6 160 110 3.9 2.875 17.02 0 1 4 4 # Wähle die ersten zwei Spalten aus aber ALLE Zeilen head(mtcars[ ,1:2], 5) ## mpg cyl ## Mazda RX4 21.0 6 ## Mazda RX4 Wag 21.0 6 ## Datsun 710 22.8 4 ## Hornet 4 Drive 21.4 6 ## Hornet Sportabout 18.7 8 Der Abschnitt vor dem , bezieht sich also auf die Zeilen und danach auf die Spalten. Mit subset() kann man noch spezifischer auf den Inhalt eines dataframes zugreifen und auch mit logischen Operatoren arbeiten. Es ist eine der wichtigsten Funktionen um auf Daten zurückzugreifen. Argument Beschreibung x Name des dataframes subset Ein logischer Vektor der Werte die man behalten möchte select Die Spalten die man behalten möchte # Wähle nur Autos mit mehr als 5 Zylinder aus head(subset(mtcars, subset = cyl &gt; 5), 5) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 # Wähle nur Autos mit mehr als 5 Zylinder &amp; &gt; 100 PS aus head(subset(mtcars, subset = cyl &gt; 5 &amp; hp &gt; 100), 5) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 # Wähle nur Autos mit mehr als 5 Zylinder &amp; &gt; 100 PS aus &amp; dabei weniger als 15 Meilen pro Gallone fahren head(subset(mtcars, subset = cyl &gt; 5 &amp; hp &gt; 100 &amp; mpg &lt; 15), n = 5) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Duster 360 14.3 8 360 245 3.21 3.570 15.84 0 0 3 4 ## Cadillac Fleetwood 10.4 8 472 205 2.93 5.250 17.98 0 0 3 4 ## Lincoln Continental 10.4 8 460 215 3.00 5.424 17.82 0 0 3 4 ## Chrysler Imperial 14.7 8 440 230 3.23 5.345 17.42 0 0 3 4 ## Camaro Z28 13.3 8 350 245 3.73 3.840 15.41 0 0 3 4 Wenn ihr also mit richtigen (unter heutigen Gesichtspunkten) Drecksschleudern rumfahren wollt, dann habt ihr durch logisches Filtern eine gute Auswahl getroffen. Diese fünf Autos erfüllen unsere drei gesetzten Kriterien. Hier findet ihr eine Auflistung der logischen Operatoren in R: Logischer Operator Bedeutung == Gleich != Nicht gleich &lt; Kleiner als &lt;= Kleiner als oder gleich &gt; Größer als &gt;= Größer als oder gleich | Oder ! Nicht %in% Durchsuche in Mit der Hilfe von &amp; (UND), | (ODER), %in% (VIELE ODER ARGUMENTE) können Abfragen wie &gt; oder &lt; ergänzt werden. "],["erstellen-von-eigenen-funktionen.html", "3.7 Erstellen von eigenen Funktionen", " 3.7 Erstellen von eigenen Funktionen Wie wir einzelne Funktionen (bspw. mean() und sd()) anwenden haben wir bereits gelernt. Wir können aber auch selber eine Anwendung oder Funktion schreiben, in der mehrere Funktionen gebündelt sind. Viele Schritte in der Datenaufbereitung und Analyse wiederholen sich ständig. Daher ist es sinnvoll bestimmte Schritte zu automatisieren. Wollen wir zum Beispiel statistische Werte zum mtcars Datensatz haben, so können wir jeden Wert einzeln abfragen mit length(mtcars$hp) # Anzahl der Werte ## [1] 32 mean(mtcars$hp) # Arithmetisches Mittel ## [1] 146.6875 sd(mtcars$hp) # Standardabweichung ## [1] 68.56287 min(mtcars$hp) # Minimum ## [1] 52 max(mtcars$hp) # Maximum ## [1] 335 median(mtcars$hp) # Median ## [1] 123 Eine Möglichkeit wiederholte Abfragen zu ermöglichen ist das Ablegen in einen einzelnen Vektor: mtcars_hp_descriptives &lt;- c( n = length(mtcars$hp), mean = mean(mtcars$hp), sd = sd(mtcars$hp), min = min(mtcars$hp), max = max(mtcars$hp), median = median(mtcars$hp) ) mtcars_hp_descriptives ## n mean sd min max median ## 32.00000 146.68750 68.56287 52.00000 335.00000 123.00000 Et voila  Eingabe des Objektes mtcars_hp_descriptives ermöglicht es uns die statistischen Kennwerte direkt auszugeben. Im mtcars Datensatz gibt es aber noch weitere Kenndaten. Wie können wir den code so anpassen, dass wir nicht jedes mal alles wieder neu abtippen müssen. Es wäre doch zu schön wenn so etwas in R möglich ist. Zwei Argumente warum ihr euch bei diesen Schritten gut überlegen solltet eine Funktion zu schreiben: Anstatt mehrerer Codezeilen ist in Zukunft für dasselbe Ergebnis eine Codezeile  der Funktionsaufruf  erforderlich. Der Code bzw. euer Skript wird weniger redundant und übersichtlicher Fehlerkorrekturen und Anpassungen werden vereinfacht, da ihr nur die Funktion ändern müsst und nicht jedes mal die Stellen wo die Funktion auftritt. Funktionen in R sind Objekte und werden ebenfalls mit dem &lt;- zugewiesen. Das Schema ist dabei immer das folgende mit drei zentralen Komponenten: Funktionsargumente, wie bei unseren bisherigen Funktionen auch (bspw. na.rm = TRUE) Body der Funktion, welcher den Code zum Ausführen enthält environment, beinhaltet die Datenstruktur damit die Funktion einen Wert mit dem Namen assoziieren kann funktionsname &lt;- function(argument_1, argument_2) { # Body: Code, der ausgeführt wird } Mit der Funktion function() weisen wir einem Objektnamen ein Funktionsobjekt zu. Um den Code auf eine andere Variable anzuwenden, müssten wir jeweils mtcars$hp ersetzen  z. B. durch mtcars$cyl oder eine Variable aus einem anderen Datensatz. Wir möchten diesen Teil also durch einen Platzhalter ersetzen, den wir dann als Funktionsargument übergeben können. Mit einem generischen Platzhalter, den wir der Einfachheit halber als x bezeichnen, sähe der Code also wie folgt aus: descriptives &lt;- function(x) { # Wir definieren &#39;x&#39; als Argument descriptives_vector &lt;- c( n = length(x), mean = mean(x), sd = sd(x), min = min(x), max = max(x), median = median(x) ) } Die Funktionsargumente werden in eine runde Klammer geschrieben () und der body in eine eckige []. Unter Environment taucht unsere Funktion descriptives nun bei der Rubrik Funktionen auf und kann im Folgenden eingesetzt werden. descriptives(mtcars$disp) Komisch das uns die Werte noch nicht angezeigt werden. Dies liegt daran, dass wir abschließend noch definieren müssen, was die Funktion mit der Anfrage durchführen soll. Vereinfacht gesagt, die Werte sollen angezeigt werden. descriptives &lt;- function(x) { # Wir definieren &#39;x&#39; als Argument descriptives_vector &lt;- c( n = length(x), mean = mean(x), sd = sd(x), min = min(x), max = max(x), median = median(x) ) return(descriptives_vector) # oder nur descriptives_vector } descriptives(mtcars$cyl) # Zusammenfassung der Zylinder ## n mean sd min max median ## 32.000000 6.187500 1.785922 4.000000 8.000000 6.000000 descriptives(mtcars$mpg) # Zusammenfassung des Verbrauchs ## n mean sd min max median ## 32.000000 20.090625 6.026948 10.400000 33.900000 19.200000 descriptives(mtcars$gear) # Zusammenfassung Anzahl der Gänge ## n mean sd min max median ## 32.0000000 3.6875000 0.7378041 3.0000000 5.0000000 4.0000000 Falls wir jedoch fehlende Werte NAs in unserem Datensatz haben müssen wir die Funktion anpassen, da dies in den Funktionsargumenten momentan noch fehlt. descriptives &lt;- function(x, na.rm = TRUE) { # Default-Wert für &#39;na.rm&#39; = TRUE descriptives_vector &lt;- c( n = length(x), mean = mean(x, na.rm = na.rm), sd = sd(x, na.rm = na.rm), min = min(x, na.rm = na.rm), max = max(x, na.rm = na.rm), median = median(x, na.rm = na.rm) ) return(descriptives_vector) } a &lt;- c(3,6,12,4,NA) descriptives(a) ## n mean sd min max median ## 5.000000 6.250000 4.031129 3.000000 12.000000 5.000000  Anstelle von TRUE oder FALSE erkennt R auch ein einfaches T oder F. Viele Funktionen haben default als vordefinierte Argumente. Diese könnten wir auch in unserer Funktion ergänzen indem wir na.rm = setzen: Dieser Default-Wert wird nun also immer verwendet, wenn wir das Argument nicht angegeben haben. Unsere Funktion ist somit noch flexibler geworden. 3.7.1 Speziellere Anwendungen von Funktionen Lasst uns diese Kenntnisse erweitern und unsere Daten mit Statistikparametern plotten: spezialplot &lt;- function(x = rnorm(100), y = rnorm(100), add.mean = FALSE, add.regression = FALSE, p.threshold = .05, add.modeltext = FALSE, ... # Weitere Argumente die ergänzt werden sollen ) { # Erstelle den Plot # und setze ggf. weitere Argumente wie `main` für Titel plot(x, y, ...) # Erstelle Referenzlinie vom Mittelwert wenn add.mean = TRUE if(add.mean == TRUE) { abline(h = mean(y), lty = 2) abline(v = mean(x), lty = 2) } # Erstelle Regressionlinie wenn add.regression = TRUE if(add.regression == TRUE) { model &lt;- lm(y ~ x) # Erstelle Regression mit `lm` linear model p.value &lt;- anova(model)$&quot;Pr(&gt;F)&quot;[1] # Ziehe den p Wert aus dem Objekt p.value # Definiere die Farbe in Abhängigkeit von p.value und p.threshold if(p.value &lt; p.threshold) {line.col &lt;- &quot;red&quot;} if(p.value &gt;= p.threshold) {line.col &lt;- &quot;black&quot;} abline(lm(y ~ x), col = line.col, lwd = 2) # Füge die Regressionlinie hinzu } # Add regression equation text if add.modeltext is TRUE if(add.modeltext == TRUE) { # Erstelle Regressionsdaten model &lt;- lm(y ~ x) # Extrahiere die Koeffizienten vom Objekt `model` coefficients &lt;- model$coefficients a &lt;- round(coefficients[1], 2) b &lt;- round(coefficients[2], 2) # Create text model.text &lt;- paste(&quot;Regression Equation: &quot;, a, &quot; + &quot;, b, &quot; * x&quot;, sep = &quot;&quot;) # Add text to top of plot mtext(model.text, side = 3, line = .5, cex = .8) } } Jetzt können wir in unsere Beispielfunktion Daten einsetzen aus dem mtcars Datensatz: spezialplot(x = mtcars$mpg, y = mtcars$hp) # Das sieht danach aus, dass der Verbrauch größer ist je mehr PS das Auto hat # Wir können das Überprüfen indem wir die zusätzlichen Argumente in unserer Funktion setzen spezialplot(x = mtcars$mpg, y = mtcars$hp, add.mean = TRUE, add.regression = TRUE, add.modeltext = TRUE, p.threshold = .05, xlab = &quot;Miles per gallon&quot;, ylab = &quot;Horsepower&quot;) # Und wie schaut das ganze für Gewicht und Verbrauch aus spezialplot(x = mtcars$mpg, y = mtcars$wt, add.mean = TRUE, add.regression = TRUE, add.modeltext = TRUE, p.threshold = .05, xlab = &quot;Miles per gallon&quot;, ylab = &quot;Weight (1000 lbs)&quot;) Schnelle Analyse: Je mehr Pferdestärken und je größer das Gewicht, desto größer ist auch der Verbrauch des Autos.  Anstelle eine Funktion immer wieder aufs neue zu schreiben empfiehlt es sich ein R Skript anzulegen unter File -&gt; New File -&gt; R script. Hier könnt ihr eure Funktionen reinschreiben, in eurem Projektordner hinterlegen und mit der Funktion source automatisch in eure aktuelle R session hineinladen. Das spart Platz und beschleunigt eure explorative Datenanlyse erheblich. # Evaluiere den Code in meinem `custom_function` script zu Beginn meiner Session source(file = &quot;custom_functions.R&quot;) 3.7.2 Nutze ... als Platzhalter Wenn man nicht alle Argumente in einer Funktion definieren möchte, sich dieses aber noch für später offen lassen möchte: descriptives &lt;- function(x, ...) { # Here is where the additional arguments go descriptives_vector &lt;- c( n = length(x), mean = mean(x, ...), # and here sd = sd(x, ...), min = min(x, ...), max = max(x, ...), median = median(x, ...) ) return(descriptives_vector) } a &lt;- c(3,6,12,4,NA) descriptives(a, na.rm = T) ## n mean sd min max median ## 5.000000 6.250000 4.031129 3.000000 12.000000 5.000000 "]]
>>>>>>> 267c07bc527bdaad545501409f2f10dd93abaf07
